<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>vscode + Remote SSH + clangd Linux内核源码阅读环境搭建</title>
      <link href="2022/04/04/vscode-remote-ssh-clangd-linux-nei-he-yuan-ma-yue-du-huan-jing-da-jian/"/>
      <url>2022/04/04/vscode-remote-ssh-clangd-linux-nei-he-yuan-ma-yue-du-huan-jing-da-jian/</url>
      
        <content type="html"><![CDATA[<h3 id="1、vscode-Remote-SSH-远程连接Linux虚拟机"><a href="#1、vscode-Remote-SSH-远程连接Linux虚拟机" class="headerlink" title="1、vscode + Remote SSH 远程连接Linux虚拟机"></a>1、vscode + Remote SSH 远程连接Linux虚拟机</h3><h4 id="环境说明"><a href="#环境说明" class="headerlink" title="环境说明"></a>环境说明</h4><ul><li>vscode运行在Windows环境</li><li>Linux虚拟机是在Windows环境下通过VMWare安装<ul><li>Linux版本：openEuler 22.03</li><li>涉及到的软件包安装基本上都是基于 rpm 包安装的</li></ul></li></ul><h4 id="连接配置过程"><a href="#连接配置过程" class="headerlink" title="连接配置过程"></a>连接配置过程</h4><ol><li><p>安装 <code>Remote - SSH</code> 插件</p><img src="/2022/04/04/vscode-remote-ssh-clangd-linux-nei-he-yuan-ma-yue-du-huan-jing-da-jian/image-20220403224411641.png" class="" title="image-20220403224411641"></li><li><p>添加远程主机</p><p>首先，打开 vscode 命令输入栏（快捷键 <code>F1</code> 或 <code>Ctrl + Shift + P</code>），搜索 <code>Remote-SSH: Connect to Host...</code> ，回车。</p><img src="/2022/04/04/vscode-remote-ssh-clangd-linux-nei-he-yuan-ma-yue-du-huan-jing-da-jian/image-20220403225031001.png" class="" title="image-20220403225031001"><p>在连接窗口中，输入你要远程连接的远程主机（这里是我的Linux虚拟机），输入格式为：<code>user@host</code>，如 <code>root@192.168.0.111</code> ，回车。</p><img src="/2022/04/04/vscode-remote-ssh-clangd-linux-nei-he-yuan-ma-yue-du-huan-jing-da-jian/image-20220403225402199.png" class="" title="image-20220403225402199"><p>此时会弹出一个新的 vscode 窗口，依此选择远程主机的系统类型（我的是 <code>Linux</code>），输入远程主机的密码，回车。</p><img src="/2022/04/04/vscode-remote-ssh-clangd-linux-nei-he-yuan-ma-yue-du-huan-jing-da-jian/image-20220403225628384.png" class="" title="image-20220403225628384"><p>如果一切正常的话，你将成功连上你的远程主机，此时 vscode 窗口左下角会出现 <code>SSH: 192.168.x.x</code> 表示你连上的远程主机IP。另外，你可以在 <code>explorer</code> 侧边栏点击 <code>OpenFolder</code> ，此时会弹出远程主机的文件目录结构，选择一个文件夹作为你的工作目录即可。</p><img src="/2022/04/04/vscode-remote-ssh-clangd-linux-nei-he-yuan-ma-yue-du-huan-jing-da-jian/image-20220403230253618.png" class="" title="image-20220403230253618"><p>至此，你就可以直接在Windows环境下通过 vscode 操作远程主机上的代码了。</p></li></ol><h4 id="遇到的问题"><a href="#遇到的问题" class="headerlink" title="遇到的问题"></a>遇到的问题</h4><ol><li><p>远程主机一直连不上，打开 vscode 的输出控制台，打印 <code>open failed: administratively prohibited: open failed</code> 字样的错误。</p><p>去 vscode 官网，查看 Remote-SSH 插件的问题处理文档：<a href="https://code.visualstudio.com/docs/remote/troubleshooting#_troubleshooting-hanging-or-failing-connections">https://code.visualstudio.com/docs/remote/troubleshooting#_troubleshooting-hanging-or-failing-connections</a> ，搜索关键字，找到相应的解决办法。</p><img src="/2022/04/04/vscode-remote-ssh-clangd-linux-nei-he-yuan-ma-yue-du-huan-jing-da-jian/image-20220403231328858.png" class="" title="image-20220403231328858"></li></ol><h3 id="2、安装-clangd-插件"><a href="#2、安装-clangd-插件" class="headerlink" title="2、安装 clangd 插件"></a>2、安装 <code>clangd</code> 插件</h3><p>安装 <code>clangd</code> 插件，安装好后在 <code>settings.json</code> 中添加如下 <code>clangd</code> 的配置（可按需扩展），</p><pre class="line-numbers language-json" data-language="json"><code class="language-json"><span class="token property">"clangd.arguments"</span><span class="token operator">:</span> <span class="token punctuation">[</span>    <span class="token string">"--compile-commands-dir=$&#123;workspaceFolder&#125;"</span><span class="token punctuation">,</span>    <span class="token string">"--background-index"</span><span class="token punctuation">,</span>    <span class="token string">"--completion-style=detailed"</span><span class="token punctuation">,</span>    <span class="token string">"-log=info"</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>注意，<code>clangd</code> 插件跟 <code>C/C++</code> 插件是冲突的，如果使用 <code>clangd</code> 的功能，需要禁用 <code>C/C++</code> 插件。</p><pre class="line-numbers language-json" data-language="json"><code class="language-json"><span class="token property">"C_Cpp.intelliSenseEngine"</span><span class="token operator">:</span> <span class="token string">"Disabled"</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>另外，在使用 <code>Remote - SSH</code> 连接上远程 Linux 虚拟机后，需要同时在远程 Linux 虚拟机上安装 <code>clangd</code> 插件，根据 <code>Extensions</code> 侧边栏 <code>clangd</code> 插件的提示按钮 <code>Install in SSH: 192.168.x.x</code> 点击安装即可（可能安装不成功，看后面手动安装步骤）。安装好后，拷贝 <code>clangd</code> 插件的配置到远程 Linux 虚拟机上的 <code>clangd</code> 上，同时配置远程 Linux 虚拟机上安装的 <code>clangd</code> 的可执行文件路径。</p><img src="/2022/04/04/vscode-remote-ssh-clangd-linux-nei-he-yuan-ma-yue-du-huan-jing-da-jian/image-20220404115705791.png" class="" title="image-20220404115705791"><h4 id="手动在远程-Linux-虚拟机上安装-clangd"><a href="#手动在远程-Linux-虚拟机上安装-clangd" class="headerlink" title="手动在远程 Linux 虚拟机上安装 clangd"></a>手动在远程 Linux 虚拟机上安装 <code>clangd</code></h4><ol><li><p>直接在 github 发布页面上下载 <code>clangd</code> 的二进制包，我下载的是 <code>13.0.0</code> 版本的 <code>clangd</code> ： <a href="https://github.com/clangd/clangd/releases/tag/13.0.0">https://github.com/clangd/clangd/releases/tag/13.0.0</a></p></li><li><p>拷贝二进制包到 Linux 安装目录，解压即可。</p><pre class="line-numbers language-sh" data-language="sh"><code class="language-sh">unzip clangd-linux-13.0.0.zip<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>在解压后的文件夹中找到二进制文件 <code>clangd</code> 的文件路径，并在 vscode 中配置远程 Linux 虚拟机上安装的 <code>clangd</code> 的可执行文件路径。（如上所述）</p></li></ol><h3 id="3、生成-clangd-需要的配置文件-compile-commands-json"><a href="#3、生成-clangd-需要的配置文件-compile-commands-json" class="headerlink" title="3、生成 clangd 需要的配置文件 compile_commands.json"></a>3、生成 <code>clangd</code> 需要的配置文件 <code>compile_commands.json</code></h3><h4 id="安装-bear"><a href="#安装-bear" class="headerlink" title="安装 bear"></a>安装 bear</h4><ol><li>直接在 <a href="https://koji.fedoraproject.org/koji/">https://koji.fedoraproject.org/koji/</a> 下载合适的 bear 版本的 rpm 包，我下载的版本 <code>bear-2.4.4-1.fc31</code> 。</li><li>将 rpm 包拷到 Linux 虚拟机上，通过 <code>yum install bear-2.4.4-1.fc31.x86_64.rpm</code> 安装即可。</li></ol><h4 id="编译内核代码生成compile-commands-json"><a href="#编译内核代码生成compile-commands-json" class="headerlink" title="编译内核代码生成compile_commands.json"></a>编译内核代码生成<code>compile_commands.json</code></h4><p>参考文档：<a href="https://www.cyberciti.biz/tips/compiling-linux-kernel-26.html">https://www.cyberciti.biz/tips/compiling-linux-kernel-26.html</a></p><ol><li><p>下载指定的内核版本的源码包，可以直接去官网下载：<a href="https://www.kernel.org/">https://www.kernel.org/</a></p></li><li><p>解压源码包 <code>tar -zxvf kernel.tar.gz</code> ，并进入源码包的根目录。</p></li><li><p>可以直接拷贝当前Linux虚拟机的内核配置文件（<code>cp -v /boot/config-$(uname -r) .config</code>），或直接使用 <code>make menuconfig</code> 来配置内核支持的特性和模块配置。</p></li><li><p>安装编译依赖的工具包</p><pre class="line-numbers language-sh" data-language="sh"><code class="language-sh">yum group install &quot;Development Tools&quot;yum install ncurses-devel bison flex elfutils-libelf-devel openssl-devel<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li><li><p>使用 <code>bear</code> 编译内核，执行 <code>bear make -j 8</code></p></li><li><p>编译完成后，会在源码包的根目录下生成 <code>compile_commands.json</code> 文件。</p></li></ol><h3 id="4、通过-vscode-阅读内核源码，可自由跳转了"><a href="#4、通过-vscode-阅读内核源码，可自由跳转了" class="headerlink" title="4、通过 vscode 阅读内核源码，可自由跳转了"></a>4、通过 vscode 阅读内核源码，可自由跳转了</h3><video src="/2022/04/04/vscode-remote-ssh-clangd-linux-nei-he-yuan-ma-yue-du-huan-jing-da-jian/clangd-效果图-2022-04-04.mp4" type='video/mp4' controls='controls'  width='100%' height='100%'></video>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Go语言：select语句</title>
      <link href="2022/01/16/go-yu-yan-select-yu-ju/"/>
      <url>2022/01/16/go-yu-yan-select-yu-ju/</url>
      
        <content type="html"><![CDATA[<p>[toc]</p><h2 id="Go语言：select语句"><a href="#Go语言：select语句" class="headerlink" title="Go语言：select语句"></a>Go语言：select语句</h2><h3 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h3><p>功能：select 随机执行一个可运行的 case。如果没有 case 可运行，它将阻塞，直到有 case 可运行。</p><p>语法：</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">select</span> <span class="token punctuation">&#123;</span><span class="token keyword">case</span> clauseA<span class="token punctuation">:</span>    statementA<span class="token keyword">case</span> clauseB<span class="token punctuation">:</span>    statementB<span class="token keyword">default</span><span class="token punctuation">:</span>    statementC<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>说明：</p><ul><li>case 中表达式必须是 Channel 收发操作。</li><li>无论哪一个表达式返回，都会立刻执行 case 中的代码。</li><li>当 select 中两个 case 同时被触发时，会随机执行其中一个，从而避免饥饿问题发生。</li><li>default 语句：提供非阻塞的收发的特性。若存在可收发的 Channel ，直接处理该 case 的语句；否则，执行 default 中的语句。</li></ul><p>select 能够让 Goroutine 同时等待多个 Channel 可读或可写，在多个文件或者 Channel 状态改变之前，select 会一直阻塞当前线程或 Goroutine 。</p><h3 id="select-的几种使用场景"><a href="#select-的几种使用场景" class="headerlink" title="select 的几种使用场景"></a>select 的几种使用场景</h3><ol><li><p>阻塞操作</p><p>使用空的 select 语句，会直接阻塞当前 Goroutine，导致 Goroutine 进入无法被唤醒的永久休眠状态。</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">example</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">select</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li><li><p>单一管道</p><p>select 中只包含一个 case ，编译器会将 select 改写成 if 条件语句。若 case 中 Channel 是空指针时，会直接挂起当前 Goroutine 并陷入永久休眠。</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">example</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    c <span class="token operator">:=</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token keyword">chan</span> <span class="token builtin">string</span><span class="token punctuation">)</span>        <span class="token keyword">go</span> <span class="token keyword">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        time<span class="token punctuation">.</span><span class="token function">Sleep</span><span class="token punctuation">(</span>time<span class="token punctuation">.</span>Second<span class="token punctuation">)</span>        c <span class="token operator">&lt;-</span> <span class="token string">"one message"</span>    <span class="token punctuation">&#125;</span>        <span class="token keyword">select</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">case</span> msg <span class="token operator">:=</span> <span class="token operator">&lt;-</span> c<span class="token punctuation">:</span>        fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"received"</span><span class="token punctuation">,</span> msg<span class="token punctuation">)</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">// 等价于</span>    <span class="token comment">// if msg := &lt;- c &#123;</span>    <span class="token comment">//     fmt.Println("received", msg)</span>    <span class="token comment">// &#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>非阻塞操作：</p><p>select中包含多个case，且其中一个是 default 语句。若不存在可收发的 Channel ，直接执行 default 中的语句。</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">example</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    c <span class="token operator">:=</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token keyword">chan</span> <span class="token builtin">string</span><span class="token punctuation">)</span>        <span class="token keyword">select</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">case</span> msg <span class="token operator">:=</span> <span class="token operator">&lt;-</span> c<span class="token punctuation">:</span>        fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"received"</span><span class="token punctuation">,</span> msg<span class="token punctuation">)</span>    <span class="token keyword">default</span><span class="token punctuation">:</span>        fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"no message received"</span><span class="token punctuation">)</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ol><h3 id="编译器对-select-的处理"><a href="#编译器对-select-的处理" class="headerlink" title="编译器对 select 的处理"></a>编译器对 select 的处理</h3><p>编译器对 select 语句的一般处理流程：</p><ol><li>将所有 case 转换成包含 Channel 以及类型等信息的 <code>runtime.scase</code> 结构体。</li><li>调用 <code>runtime.selectgo</code> 从多个就绪的 Channel 中选择一个可执行的 <code>runtime.scase</code> 结构体。</li><li>通过 for 循环生成一组 if 语句，在语句中判断自己是不是被选中的 case 。</li></ol><p>随机执行的关键运行时函数：<code>runtime.selectgo</code> ，它的执行步骤为，</p><ol><li>确定 case 的处理顺序<ul><li>轮询顺序：通过 <code>runtime.fastrandom</code> 函数引入随机性。</li><li>加锁顺序：按照 Channel 的地址排序后确定加锁顺序。</li></ul></li><li>根据轮询顺序遍历所有的 case ，查看是否有可立即处理的 Channel 。<ul><li>如果存在，直接获取 case 对应的索引并返回</li><li>否则，创建 <code>runtime.sudog</code> 结构体，并将当前 Goroutine 加入到所有相关的 Channel 收发队列，并调用 <code>runtime.gopark</code> 挂起当前 Goroutine ，等待调度器的唤醒。</li></ul></li><li>当调度器唤醒当前 Goroutine 时，会再次按照加锁顺序遍历所有的 case ，从中查找需要被处理的 <code>runtime.sudog</code> 对应的索引。</li></ol><p>select 关键字是 Go 语言特有的控制结构，需要编译器和运行时函数共同实现。</p>]]></content>
      
      
      <categories>
          
          <category> golang </category>
          
      </categories>
      
      
        <tags>
            
            <tag> go </tag>
            
            <tag> select </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>linked-list-cycle-ii</title>
      <link href="2021/05/05/linked-list-cycle-ii/"/>
      <url>2021/05/05/linked-list-cycle-ii/</url>
      
        <content type="html"><![CDATA[<p>[toc]</p><p>Leetcode链接：<a href="https://leetcode-cn.com/problems/linked-list-cycle-ii/">https://leetcode-cn.com/problems/linked-list-cycle-ii/</a></p><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定一个链表，返回链表开始入环的第一个节点。 如果链表无环，则返回 null。</p><p>为了表示给定链表中的环，我们使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。 如果 pos 是 -1，则在该链表中没有环。注意，pos 仅仅是用于标识环的情况，并不会作为参数传递到函数中。</p><p>说明：不允许修改给定的链表。</p><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>分两个步骤，</p><ul><li>首先通过快慢指针的方法判断链表是否有环；</li><li>接下来如果有环，则寻找入环的第一个节点。</li></ul><p>判断链表是否有环很简单，如果快指针为 null 时，则链表无环；否则有环。</p><p>如果有环，则寻找入环的第一个节点，具体的方法为，</p><p>首先假定链表起点到入环的第一个节点A的长度为a【未知】，到快慢指针相遇的节点B的长度为（a + b）【这个长度是已知的】。</p><img src="/2021/05/05/linked-list-cycle-ii/image-20210505230754000.png" class="" title="image-20210505230754000"><p>现在我们想知道a的值，注意到快指针 p_fast 始终是慢指针p走过长度的2倍，所以慢指针 p_slow 从B继续走（a + b）又能回到B点，如果只走a个长度就能回到节点A。</p><img src="/2021/05/05/linked-list-cycle-ii/image-20210505230537824.png" class="" title="image-20210505230537824"><p>但是a的值是不知道的，解决思路是曲线救国，注意到起点到A的长度是a，那么可以用一个从起点开始的新慢指针 p_slow2 和从节点B开始的慢指针 p_slow 同步走，相遇的地方必然是入环的第一个节点A。 </p><img src="/2021/05/05/linked-list-cycle-ii/image-20210505230632200.png" class="" title="image-20210505230632200"><h2 id="编码实现"><a href="#编码实现" class="headerlink" title="编码实现"></a>编码实现</h2><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">/** * Definition for singly-linked list. * class ListNode &#123; *     int val; *     ListNode next; *     ListNode(int x) &#123; *         val = x; *         next = null; *     &#125; * &#125; */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">public</span> <span class="token class-name">ListNode</span> <span class="token function">detectCycle</span><span class="token punctuation">(</span><span class="token class-name">ListNode</span> head<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>head <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span>            <span class="token keyword">return</span> <span class="token keyword">null</span><span class="token punctuation">;</span>                <span class="token comment">// 步骤一：使用快慢指针判断链表是否有环</span>        <span class="token class-name">ListNode</span> p <span class="token operator">=</span> head<span class="token punctuation">,</span> p2 <span class="token operator">=</span> head<span class="token punctuation">;</span>        <span class="token keyword">boolean</span> hasCycle <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>p2<span class="token punctuation">.</span>next <span class="token operator">!=</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> p2<span class="token punctuation">.</span>next<span class="token punctuation">.</span>next <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            p <span class="token operator">=</span> p<span class="token punctuation">.</span>next<span class="token punctuation">;</span>            p2 <span class="token operator">=</span> p2<span class="token punctuation">.</span>next<span class="token punctuation">.</span>next<span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>p <span class="token operator">==</span> p2<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                hasCycle <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>                <span class="token keyword">break</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>                <span class="token comment">// 步骤二：若有环，找到入环开始的节点</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>hasCycle<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token class-name">ListNode</span> q <span class="token operator">=</span> head<span class="token punctuation">;</span>            <span class="token keyword">while</span> <span class="token punctuation">(</span>p <span class="token operator">!=</span> q<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                p <span class="token operator">=</span> p<span class="token punctuation">.</span>next<span class="token punctuation">;</span>                q <span class="token operator">=</span> q<span class="token punctuation">.</span>next<span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>            <span class="token keyword">return</span> q<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span> <span class="token keyword">else</span>             <span class="token keyword">return</span> <span class="token keyword">null</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 算法与数据结构 </category>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 快慢指针 </tag>
            
            <tag> 链表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hexo上markdown图片路径与Typora保持一致</title>
      <link href="2021/05/05/hexo-shang-markdown-tu-pian-lu-jing-yu-typora-bao-chi-yi-zhi/"/>
      <url>2021/05/05/hexo-shang-markdown-tu-pian-lu-jing-yu-typora-bao-chi-yi-zhi/</url>
      
        <content type="html"><![CDATA[<p>Typora是一款很好用的markdown语法编辑器，我希望使用Typora写好博客后，直接通过hexo部署到个人博客主页上面去。但有个问题是，如果markdown文件里面有图片路径时，在部署到hexo上时需要重新修改图片路径，否则会有问题。每次手动修改显然很麻烦，因此需要看看hexo是否有比较友好的支持。</p><p>Typora本地插入图片的路径有两种方式：一个是绝对路径，一个是相对路径（相对于当前文件所在的路径）。</p><p>Hexo通过<code>hexo-renderer-marked</code>插件实现了对markdown语法的支持，其中默认插入图片的方式为 <code>![](/images/image.jpg)</code> ，它是一个相对路径（相对于Hexo工作目录下的 <code>source</code> 文件夹）的方式。</p><p>首先，如果Typora使用本地的绝对路径插入图片，那么在执行 <code>hexo g</code> 时需要将本地的绝对路径转换成对应的相对路径，这个目前暂未看到有相关的插件实现。</p><p>其次，如果Typora使用相对路径插入图片，问题在于Typora和Hexo所相对的路径是不一致的。对此，Hexo提供了一个更组织化的方式来管理资源，可以通过将 <code>_config.yml</code> 配置文件中的 <code>post_asset_folder</code> 选项设置为 <code>true</code> 来打开。</p><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"><span class="token comment"># _config.yml</span><span class="token key atrule">post_asset_folder</span><span class="token punctuation">:</span> <span class="token boolean important">true</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>该功能打开后，Hexo将会在你每一次通过 <code>hexo new [layout] &lt;title&gt;</code> 命令创建新文章时自动创建一个文件夹。这个资源文件夹名与这个文章文件名相同。将所有与你的文章有关的资源（如图片）放在这个关联文件夹中之后，你可以通过相对路径来引用它们。如，我使用 <code>hexo new mytitle</code> 创建了一篇文章 <code>mytitle.md</code> ，会同时在该文章文件所在的路径上创建文件夹 <code>mytitle/</code>，我们在该文件夹里面添加图片 <code>mytitle/my.png</code>，这时我们在 <code>mytitle.md</code> 文件中插入该图片的方式为 <code>![](my.png)</code> 就可以了。</p><p>跟Typora很接近了，但Typora需要的是 <code>&#123;% asset_img my.png  %&#125;</code> （此处显示有个bug，Hexo自动将满足 <code>mytitle/my.png</code> 格式的图片路径转换成Hexo图片标签插件了，而实际上这里我用了反引号，按理说不应该转义的。。。），即</p><pre class="line-numbers language-none"><code class="language-none">![](mytitle&#x2F;my.png)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>因此还需要一步转换：<code>mytitle/my.png  -&gt; my.png</code> 。幸运的是，Hexo提供了一款插件 <code>hexo-image-link</code> 来实现这一步转换，在Hexo根目录下执行 <code>npm install hexo-image-link --save</code> 安装该插件即可，无需额外的配置。</p><p>至此，问题解决！总结下来操作上只需要做两个步骤即可：</p><ol><li><p>安装插件 <code>hexo-image-link</code></p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">npm install hexo-image-link --save<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>打开Hexo资源管理配置开关</p><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"><span class="token comment"># _config.yml</span><span class="token key atrule">post_asset_folder</span><span class="token punctuation">:</span> <span class="token boolean important">true</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li></ol><p>最后，上一个例子，在本篇博客最后编辑一行，</p><pre class="line-numbers language-none"><code class="language-none">&#x2F;&#x2F; source&#x2F;_posts&#x2F;2021&#x2F;05&#x2F;05&#x2F;Hexo上markdown图片路径与Typora保持一致.md![](Hexo上markdown图片路径与Typora保持一致&#x2F;古剑3.jpg)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>接下来你可以看到本篇博客显示如下图片，</p><img src="/2021/05/05/hexo-shang-markdown-tu-pian-lu-jing-yu-typora-bao-chi-yi-zhi/%E5%8F%A4%E5%89%913.jpg" class="">]]></content>
      
      
      <categories>
          
          <category> 环境 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 博客 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
