<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>设计模式学习导读</title>
      <link href="2022/05/07/she-ji-mo-shi-xue-xi-dao-du/"/>
      <url>2022/05/07/she-ji-mo-shi-xue-xi-dao-du/</url>
      
        <content type="html"><![CDATA[<p>课程笔记：<a href="https://time.geekbang.org/column/intro/100039001">极客时间—设计模式之美</a></p><h2 id="设计模式学习导读"><a href="#设计模式学习导读" class="headerlink" title="设计模式学习导读"></a>设计模式学习导读</h2><h3 id="为什么要学习设计模式？"><a href="#为什么要学习设计模式？" class="headerlink" title="为什么要学习设计模式？"></a>为什么要学习设计模式？</h3><ol><li>应对面试中的设计模式相关问题</li><li>告别写被别人吐槽的烂代码</li><li>提高复杂代码的设计和开发能力</li><li>让读源码、学框架事半功倍</li><li>为你的职场发展做铺垫</li></ol><p>有些能力，要早点锻炼；有些东西，要早点知道；有些书，要早点读。这样在你后面的生活、工作、学习中，才能一直发挥作用。不要等到好多年后，看到了，才恍然大悟，后悔没有早点去学、去看。</p><p>设计模式作为一门与编程、开发有着直接关系的基础知识，是你现在就要开始学习的。早点去学习，以后的项目就都可以拿来锻炼，每写一行代码都是对内功的利用和加深，是可以受益一整个职业生涯的事情。</p><h3 id="从哪些维度评判代码质量的好坏？"><a href="#从哪些维度评判代码质量的好坏？" class="headerlink" title="从哪些维度评判代码质量的好坏？"></a>从哪些维度评判代码质量的好坏？</h3><p>写出好代码的前提：能够辨别代码写得”好“还是”烂“。</p><p>评价代码质量好坏的认知：</p><ul><li>需要综合各种因素来进行评价。</li><li>不同的评价维度也并不是完全独立的，有些是具有包含关系、重叠关系或者可以互相影响的。</li><li>各种评价维度也并不是非黑即白的。</li><li>对一段代码的质量评价，常常有很强的主观性。</li></ul><h4 id="7个最常用的代码评价标准"><a href="#7个最常用的代码评价标准" class="headerlink" title="7个最常用的代码评价标准"></a>7个最常用的代码评价标准</h4><ol><li><p>可维护性（Maintainability）</p><p>什么是代码的可维护性？</p><p>“维护”主要包括修改bug、修改老的代码、添加新的代码之类的工作。</p><p>“代码易维护”是指：在不破坏原有代码设计、不引入新的bug的情况下，能够快速地修改或者添加代码。</p><p>“代码不易维护”是指：修改或者添加代码需要冒着极大的引入新bug的风险，并且需要花费很长的时间才能完成。</p><p>可维护性的重要性：对于一个项目来说，维护代码的时间远远大于编写代码的时间。工程师大部分的时间可能都是花在修修bug、改改老的功能逻辑、添加一些新的功能逻辑之类的工作上。</p><p>如何量化可维护性？</p><p>代码可维护性的好坏是一个比较主观的评价标准，如：</p><ul><li>代码的可读性好、简洁、可扩展性好，就会使得代码易维护；</li><li>更细化地讲，如果代码分层清晰、模块化好、高内聚低耦合、遵从基于接口而非实现编程的设计原则等等，那就意味着代码易维护；</li><li>代码的易维护性还跟项目代码量的多少、业务的复杂程度、技术复杂程度、文档是否全面、团队成员的开发水平等诸多因素有关；</li></ul></li><li><p>可读性（Readability）</p><p>代码的可读性应该是评价代码质量最重要的指标之一。</p><p>如何评价一段代码的可读性？</p><ul><li>代码是否符合编程规范</li><li>命名是否达意</li><li>注释是否详尽</li><li>函数是否长短合适</li><li>模块划分是否清晰</li><li>是否符合高内聚低耦合</li><li>……</li></ul><p>一个主观的评价手段：code review。如果你的同事可以轻松地读懂你写的代码，那说明你的代码可读性很好；如果同事在读你写的代码时，有很多疑问，那就说明你的代码可读性有待提高了。</p></li><li><p>可扩展性（Extensibility）</p><p>代码的可扩展性也是一个评价代码质量非常重要的标准。</p><p>它表示我们的代码应对未来需求变化的能力。</p><p>代码的可扩展性是指：我们在不修改或少量修改原有代码的情况下，通过扩展的方式添加新的功能代码。</p></li><li><p>灵活性（Flexibility）</p><p>如何理解灵活性？</p><p>灵活性是一个挺抽象的评价标准，要给它下个定义很难。我们可以通过下面的几个场景来思考什么是灵活性。</p><ul><li>场景1：当我们添加一个新的功能代码的时候，原有代码已经预留好了扩展点，我们不需要修改原有的代码，只要在扩展点上添加新的代码即可。（易扩展、灵活）</li><li>场景2：当我们要实现一个功能的时候，发现原有代码中，已经抽象出了很多底层可以复用的模块、类等代码，我们可以拿来直接使用。（易复用、灵活）</li><li>场景3：当我们使用某组接口的时候，如果这组接口可以应对各种使用场景，满足各种不同的需求。（易用、灵活）</li></ul></li><li><p>简洁性（Simplicity）</p><blockquote><p>KISS原则：”Keep It Simple, Stupid”</p></blockquote><p>代码简洁、逻辑清晰，也就意味着易读、易维护。</p><p>一个偏见：认为简单的代码没有技术含量。实际上，思从深而行从简，真正的高手能云淡风轻地用最简单的方法解决最复杂的问题。这也是一个编程老手跟编程新手的本质区别之一。</p></li><li><p>可复用性（Reusability）</p><p>代码的可复用性可以简单地理解为，尽量减少重复代码的编写，复用已有的代码。</p><p>如何提高代码的可复用性？</p><ul><li>使用继承、多态</li><li>使用单一职责原则</li><li>解耦、高内聚、模块化</li><li>应用DRY设计原则</li></ul></li><li><p>可测试性（Testability）</p><p>代码可测试性的好坏，能从侧面上非常准确地反映代码质量的好坏。</p><p>代码的可测试性差，比较难写单元测试，那基本上就能说明代码设计得有问题。</p></li></ol><h3 id="如何才能写出高质量的代码？"><a href="#如何才能写出高质量的代码？" class="headerlink" title="如何才能写出高质量的代码？"></a>如何才能写出高质量的代码？</h3><p>如何写出高质量的代码，也就等同于，如何写出易维护、易读、易扩展、灵活、简洁、可复用、可测试的代码。</p><p>要写出满足这些评价标准的高质量代码，我们需要掌握一些更加细化、更加能落地的编程方法论。包括：</p><ul><li>面向对象设计思想</li><li>设计原则</li><li>设计模式</li><li>编程规范</li><li>重构技巧</li></ul><h3 id="编程方法论"><a href="#编程方法论" class="headerlink" title="编程方法论"></a>编程方法论</h3><h4 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h4><p>面向对象因为其具有丰富的特性（封装、抽象、继承、多态），可以实现很多复杂的设计思路，是很多设计原则、设计模式编码实现的基础。</p><p>面向对象编程的相关知识点：</p><ul><li>面向对象四大特性：封装、抽象、继承、多态</li><li>面向对象编程与面向过程编程的区别和联系</li><li>面向对象分析、面向对象设计、面向对象编程</li><li>接口与抽象类的区别以及各自的应用场景</li><li>多用组合少用继承的设计思想</li><li>面向过程的贫血模型和面向对象的充血模型</li></ul><h4 id="设计原则"><a href="#设计原则" class="headerlink" title="设计原则"></a>设计原则</h4><p>设计原则是指导我们代码设计的一些经验总结。</p><p>对于每一种设计原则，我们需要掌握它的设计初衷、能解决哪些编程问题，有哪些应用场景。</p><p>几个常用的设计原则：</p><ul><li>SOLID原则——SRP单一职责原则</li><li>SOLID原则——OCP开闭原则</li><li>SOLID原则——LSP里氏替换原则</li><li>SOLID原则——ISP接口隔离原则</li><li>SOLID原则——DIP依赖倒置原则</li><li>DRY原则、KISS原则、YAGNI原则、LOD原则</li></ul><h4 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h4><p>设计模式是针对软件开发中经常遇到的一些设计问题，总结出来的一套解决方案或者设计思路。</p><p>设计模式相对于设计原则来说，没那么抽象，而且大部分都不难理解，代码实现也并不复杂。这一块的学习难点是了解它们都能解决哪些问题，掌握典型的应用场景，并且懂得不过度应用。</p><p>23中经典的设计模式：</p><ul><li><p>创建型模式</p><p>常用的有：单例模式、工厂模式（工厂方法模式、抽象工厂模式）、建造者模式</p><p>不常用的有：原型模式</p></li><li><p>结构型模式</p><p>常用的有：代理模式、桥接模式、装饰器模式、适配器模式</p><p>不常用的有：门面模式、组合模式、享元模式</p></li><li><p>行为型模式</p><p>常用的有：观察者模式、模板模式、策略模式、职责链模式、迭代器模式、状态模式。</p><p>不常用的有：访问者模式、备忘录模式、命令模式、解释器模式、中介模式。</p></li></ul><p>对于常用的设计模式，我们要多花点时间理解掌握。对于不常用的设计模式，我们只需要稍微了解即可。</p><h4 id="编程规范"><a href="#编程规范" class="headerlink" title="编程规范"></a>编程规范</h4><p>编程规范主要解决的是代码的可读性问题。</p><p>编程规范相对于设计原则、设计模式，更加具体、更加偏重代码细节。</p><p>可直接看经典书籍：《重构》、《代码整洁之道》</p><h4 id="代码重构"><a href="#代码重构" class="headerlink" title="代码重构"></a>代码重构</h4><p>软件开发是一个不停迭代的过程，因此没有一劳永逸的设计。随着需求的变化，代码的不停堆砌，原有的设计必定会存在这样或那样的问题。</p><p>重构是软件开发中非常重要的一个环节。持续重构是保持代码质量不下降的有效手段，能有效避免代码腐化到无可救药的地步。</p><p>重构的工具包括：</p><ul><li>设计思想</li><li>设计原则</li><li>设计模式</li><li>编程规范</li></ul><p>重构相关的知识点</p><ul><li>重构的目的、对象、时机、方法</li><li>保证重构不出错的技术手段：单元测试和代码的可测试性</li><li>两种不同规模的重构：大重构（大规模高层次）和小重构（小规模低层次）</li></ul><p>学习重构，不仅仅要掌握一些重构技巧、套路，更重要的是建立持续重构的意识，把重构当作开发的一部分，融入到日常的开发中。</p><h4 id="五者之间的联系"><a href="#五者之间的联系" class="headerlink" title="五者之间的联系"></a>五者之间的联系</h4><ul><li>面向对象编程因为其具有丰富的特性，可以实现很多复杂的设计思路，是很多设计原则、设计模式等编码实现的基础。</li><li>设计原则是指导我们代码设计的一些经验总结，对于某些场景下，是否应该应用某种设计模式，具有指导意义。</li><li>设计模式是针对软件开发中经常遇到的一些设计问题，总结出来的一套解决方案或者设计思路。应用设计模式的主要目的是提高代码的可扩展性。从抽象程度来说，设计原则比设计模式更抽象，设计模式更加具体、更加可执行。</li><li>编程规范主要解决的是代码的可读性问题。编程规范相较于设计原则、设计模式，更加具体、更加偏重代码细节、更加能落地。持续的小重构依赖的理论基础主要就是编程规范。</li><li>重构作为保持代码质量不下降的有效手段，利用的就是面向对象、设计原则、设计模式、编码规范这些理论。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>设计模式之装饰器模式</title>
      <link href="2022/05/07/she-ji-mo-shi-zhi-zhuang-shi-qi-mo-shi/"/>
      <url>2022/05/07/she-ji-mo-shi-zhi-zhuang-shi-qi-mo-shi/</url>
      
        <content type="html"><![CDATA[<p>课程笔记：<a href="https://time.geekbang.org/column/intro/100039001">极客时间—设计模式之美</a></p><h3 id="装饰器模式"><a href="#装饰器模式" class="headerlink" title="装饰器模式"></a>装饰器模式</h3><p>解决的问题：装饰器模式主要解决继承关系过于复杂的问题，通过组合来代替继承。</p><p>主要的作用：给原始类添加增强功能。</p><h4 id="案例讲解：通过剖析-Java-IO-类的设计思想来学习装饰器模式"><a href="#案例讲解：通过剖析-Java-IO-类的设计思想来学习装饰器模式" class="headerlink" title="案例讲解：通过剖析 Java IO 类的设计思想来学习装饰器模式"></a>案例讲解：通过剖析 Java IO 类的设计思想来学习装饰器模式</h4><p>Java IO类库的部分继承关系：</p><ul><li>字节流<ul><li><code>InputStream</code>（抽象类）<ul><li><code>PipedInputStream</code></li><li><code>FileInputStream</code></li><li><code>FilterInputStream</code><ul><li><code>BufferedInputStream</code></li><li><code>DataInputStream</code></li></ul></li></ul></li><li><code>OutputStream</code>（抽象类）</li></ul></li><li>字符流</li></ul><p>其中，<code>FileInputStream</code> 是专门用来读取文件流的子类。<code>BufferedInputStream</code>是一个支持带缓存功能的数据读取类，可以提高数据读取的效率。</p><p>考虑给 <code>FileInputStream</code> 扩展一个支持带缓存读取的功能，有两种设计方案：</p><ol><li><p>基于继承的设计方案</p><p>添加一个继承 <code>FileInputStream</code> 的子类 <code>BufferedFileInputStream</code> 来实现该功能。</p><p>该方案的问题：假如我需要再给 <code>PipedInputStream</code> 添加缓存功能，则需要再添加一个继承自 <code>PipedInputStream</code> 的子类 <code>BufferedPipedInputStream</code> ；另外，除了支持缓存读取之外，如果我们还需要对功能进行其他方面的增强，比如 <code>DataInputStream</code> 类（支持按照基本数据类型来读取数据），就需要再继续派生出 <code>DataFileInputStream</code> 、 <code>DataPipedInputStream</code> 等 n 多个子类。依此类推，如果需要附加更多的增强功能（假设有 m 个），<strong>那么就会导致组合爆炸（新增 <code>m x n</code> 个子类），类继承结构变得无比复杂，代码既不好扩展，也不好维护。</strong></p></li><li><p>基于装饰器模式的设计方案</p><p>简而言之，就是“使用组合来替代继承”。</p><p>这里给出了部分的代码实现结构：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">abstract</span> <span class="token keyword">class</span> <span class="token class-name">InputStream</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">read</span><span class="token punctuation">(</span><span class="token keyword">byte</span> b<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">IOException</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> <span class="token function">read</span><span class="token punctuation">(</span>b<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> b<span class="token punctuation">.</span>length<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>        <span class="token keyword">public</span> <span class="token keyword">long</span> <span class="token function">skip</span><span class="token punctuation">(</span><span class="token keyword">long</span> n<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">IOException</span> <span class="token punctuation">&#123;</span>        <span class="token comment">//...</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">BufferedInputStream</span> <span class="token keyword">extends</span> <span class="token class-name">InputStream</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">protected</span> <span class="token keyword">volatile</span> <span class="token class-name">InputStream</span> in<span class="token punctuation">;</span>    <span class="token keyword">protected</span> <span class="token class-name">BufferedInputStream</span><span class="token punctuation">(</span><span class="token class-name">InputStream</span> in<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>in <span class="token operator">=</span> in<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>        <span class="token comment">// 实现基于缓存的读数据接口</span><span class="token punctuation">&#125;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">DataInputStream</span> <span class="token keyword">extends</span> <span class="token class-name">InputStream</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">protected</span> <span class="token keyword">volatile</span> <span class="token class-name">InputStream</span> in<span class="token punctuation">;</span>    <span class="token keyword">protected</span> <span class="token class-name">DataInputStream</span><span class="token punctuation">(</span><span class="token class-name">InputStream</span> in<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>in <span class="token operator">=</span> in<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>        <span class="token comment">// 实现基于读取基本类型数据的接口</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>使用下面的代码，我们就可以分别创建一个支持缓存功能、和支持读取基本数据类型的读取文件流。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">InputStream</span> bin <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">BufferedInputStream</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">FileInputStream</span><span class="token punctuation">(</span><span class="token string">"/path/to/test.txt"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name">InputStream</span> din <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">DataInputStream</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">FileInputStream</span><span class="token punctuation">(</span><span class="token string">"/path/to/test.txt"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>如果总共需要添加 m 个附加功能，那我们只需要创建 m 个继承自 <code>InputStream</code> 的子类即可。</p><p>装饰器模式相对于简单的组合关系，还有两个比较特殊的地方。</p><ol><li><p>第一个特殊的地方：装饰器类和原始类继承同样的父类，这样我们可以对原始类“嵌套”多个装饰器类。</p><p>比如，下面一段代码，通过对 <code>FileInputStream</code> 嵌套了两个装饰器类，让它既支持缓存读取，又支持按照基本数据类型来读取数据。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">InputStream</span> in <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">FileInputStream</span><span class="token punctuation">(</span><span class="token string">"/path/to/test.txt"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name">InputStream</span> bin <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">BufferedInputStream</span><span class="token punctuation">(</span>in<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name">InputStream</span> din <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">DataInputStream</span><span class="token punctuation">(</span>bin<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>不得不感叹这样的设计是真的优雅。</p></li><li><p>第二个特殊的地方：装饰器类是对功能的增强，这也是装饰器模式应用场景的一个重要特点。</p><p>这里我们通过对比装饰器模式和代理模式的设计差异来加深认识。</p><p>代理模式跟装饰器模式的代码结构很像，它们都是符合“组合关系”的设计。但是，它们的设计意图是不同的。</p><ul><li>代理模式中，代理类附加的是跟原始类无关的功能；</li><li>装饰器模式中，装饰器类附加的是跟原始类相关的增强功能。</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">// 代理模式的代码结构（下面的接口可替换成抽象类）</span><span class="token keyword">public</span> <span class="token keyword">interface</span> IA <span class="token punctuation">&#123;</span>    <span class="token keyword">void</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">A</span> <span class="token keyword">implements</span> IA <span class="token punctuation">&#123;</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">AProxy</span> <span class="token keyword">implements</span> IA <span class="token punctuation">&#123;</span>    <span class="token keyword">private</span> <span class="token class-name">IA</span> a<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token class-name">AProxy</span><span class="token punctuation">(</span><span class="token class-name">IA</span> a<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>a <span class="token operator">=</span> a<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>        <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// 新添加的代理逻辑</span>        a<span class="token punctuation">.</span><span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 新添加的代理逻辑</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token comment">// 装饰器模式的代码结构（下面的接口可替换成抽象类）</span><span class="token keyword">public</span> <span class="token keyword">interface</span> IA <span class="token punctuation">&#123;</span>    <span class="token keyword">void</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">void</span> <span class="token function">f2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">A</span> <span class="token keyword">implements</span> IA <span class="token punctuation">&#123;</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">f2</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ADecorator</span> <span class="token keyword">implements</span> IA <span class="token punctuation">&#123;</span>    <span class="token keyword">private</span> <span class="token class-name">IA</span> a<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token class-name">ADecorator</span><span class="token punctuation">(</span><span class="token class-name">IA</span> a<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>a <span class="token operator">=</span> a<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>        <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// 功能增强代码</span>        a<span class="token punctuation">.</span><span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 功能增强代码</span>    <span class="token punctuation">&#125;</span>        <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">f2</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        a<span class="token punctuation">.</span><span class="token function">f2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ol><p>在装饰器模式中，即使对于不需要增强的函数来说，装饰器类还是必须把它重新实现一遍，简单包裹对被装饰类的函数调用。原因也很容易理解，装饰器类既然是对原始类功能的增强，那么原始类已有的功能就必须被继承下来。而这带来了一个问题，增加了重复代码。</p><p>聪明的你可能已经想到了解决方案：使用继承。这也是 Java IO 类的设计中，<code>BufferedInputStream</code> 并没有直接继承自 <code>InputStream</code>，而是抽象出了一个装饰器父类 <code>FilterInputStream</code> 的原因所在。这样，装饰器类只需要实现它需要增强的方法就可以了，其他方法继承装饰器父类的默认实现。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">FilterInputStream</span> <span class="token keyword">extends</span> <span class="token class-name">InputStream</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">protected</span> <span class="token keyword">volatile</span> <span class="token class-name">InputStream</span> in<span class="token punctuation">;</span>    <span class="token keyword">protected</span> <span class="token class-name">FilterInputStream</span><span class="token punctuation">(</span><span class="token class-name">InputStream</span> in<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>in <span class="token operator">=</span> in<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>        <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">read</span><span class="token punctuation">(</span><span class="token keyword">byte</span> b<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">IOException</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> in<span class="token punctuation">.</span><span class="token function">read</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>        <span class="token keyword">public</span> <span class="token keyword">long</span> <span class="token function">skip</span><span class="token punctuation">(</span><span class="token keyword">long</span> n<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">IOException</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> in<span class="token punctuation">.</span><span class="token function">skip</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ol><h4 id="装饰器模式类图"><a href="#装饰器模式类图" class="headerlink" title="装饰器模式类图"></a>装饰器模式类图</h4><p><img src="image-20220506223021312.jpg" alt="image-20220506223021312"></p>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
            <tag> 装饰器模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vscode + Remote SSH + clangd Linux内核源码阅读环境搭建</title>
      <link href="2022/04/04/vscode-remote-ssh-clangd-linux-nei-he-yuan-ma-yue-du-huan-jing-da-jian/"/>
      <url>2022/04/04/vscode-remote-ssh-clangd-linux-nei-he-yuan-ma-yue-du-huan-jing-da-jian/</url>
      
        <content type="html"><![CDATA[<h3 id="1、vscode-Remote-SSH-远程连接Linux虚拟机"><a href="#1、vscode-Remote-SSH-远程连接Linux虚拟机" class="headerlink" title="1、vscode + Remote SSH 远程连接Linux虚拟机"></a>1、vscode + Remote SSH 远程连接Linux虚拟机</h3><h4 id="环境说明"><a href="#环境说明" class="headerlink" title="环境说明"></a>环境说明</h4><ul><li>vscode运行在Windows环境</li><li>Linux虚拟机是在Windows环境下通过VMWare安装<ul><li>Linux版本：openEuler 22.03</li><li>涉及到的软件包安装基本上都是基于 rpm 包安装的</li></ul></li></ul><h4 id="连接配置过程"><a href="#连接配置过程" class="headerlink" title="连接配置过程"></a>连接配置过程</h4><ol><li><p>安装 <code>Remote - SSH</code> 插件</p><img src="/2022/04/04/vscode-remote-ssh-clangd-linux-nei-he-yuan-ma-yue-du-huan-jing-da-jian/image-20220403224411641.png" class="" title="image-20220403224411641"></li><li><p>添加远程主机</p><p>首先，打开 vscode 命令输入栏（快捷键 <code>F1</code> 或 <code>Ctrl + Shift + P</code>），搜索 <code>Remote-SSH: Connect to Host...</code> ，回车。</p><img src="/2022/04/04/vscode-remote-ssh-clangd-linux-nei-he-yuan-ma-yue-du-huan-jing-da-jian/image-20220403225031001.png" class="" title="image-20220403225031001"><p>在连接窗口中，输入你要远程连接的远程主机（这里是我的Linux虚拟机），输入格式为：<code>user@host</code>，如 <code>root@192.168.0.111</code> ，回车。</p><img src="/2022/04/04/vscode-remote-ssh-clangd-linux-nei-he-yuan-ma-yue-du-huan-jing-da-jian/image-20220403225402199.png" class="" title="image-20220403225402199"><p>此时会弹出一个新的 vscode 窗口，依此选择远程主机的系统类型（我的是 <code>Linux</code>），输入远程主机的密码，回车。</p><img src="/2022/04/04/vscode-remote-ssh-clangd-linux-nei-he-yuan-ma-yue-du-huan-jing-da-jian/image-20220403225628384.png" class="" title="image-20220403225628384"><p>如果一切正常的话，你将成功连上你的远程主机，此时 vscode 窗口左下角会出现 <code>SSH: 192.168.x.x</code> 表示你连上的远程主机IP。另外，你可以在 <code>explorer</code> 侧边栏点击 <code>OpenFolder</code> ，此时会弹出远程主机的文件目录结构，选择一个文件夹作为你的工作目录即可。</p><img src="/2022/04/04/vscode-remote-ssh-clangd-linux-nei-he-yuan-ma-yue-du-huan-jing-da-jian/image-20220403230253618.png" class="" title="image-20220403230253618"><p>至此，你就可以直接在Windows环境下通过 vscode 操作远程主机上的代码了。</p></li></ol><h4 id="遇到的问题"><a href="#遇到的问题" class="headerlink" title="遇到的问题"></a>遇到的问题</h4><ol><li><p>远程主机一直连不上，打开 vscode 的输出控制台，打印 <code>open failed: administratively prohibited: open failed</code> 字样的错误。</p><p>去 vscode 官网，查看 Remote-SSH 插件的问题处理文档：<a href="https://code.visualstudio.com/docs/remote/troubleshooting#_troubleshooting-hanging-or-failing-connections">https://code.visualstudio.com/docs/remote/troubleshooting#_troubleshooting-hanging-or-failing-connections</a> ，搜索关键字，找到相应的解决办法。</p><img src="/2022/04/04/vscode-remote-ssh-clangd-linux-nei-he-yuan-ma-yue-du-huan-jing-da-jian/image-20220403231328858.png" class="" title="image-20220403231328858"></li></ol><h3 id="2、安装-clangd-插件"><a href="#2、安装-clangd-插件" class="headerlink" title="2、安装 clangd 插件"></a>2、安装 <code>clangd</code> 插件</h3><p>安装 <code>clangd</code> 插件，安装好后在 <code>settings.json</code> 中添加如下 <code>clangd</code> 的配置（可按需扩展），</p><pre class="line-numbers language-json" data-language="json"><code class="language-json"><span class="token property">"clangd.arguments"</span><span class="token operator">:</span> <span class="token punctuation">[</span>    <span class="token string">"--compile-commands-dir=$&#123;workspaceFolder&#125;"</span><span class="token punctuation">,</span>    <span class="token string">"--background-index"</span><span class="token punctuation">,</span>    <span class="token string">"--completion-style=detailed"</span><span class="token punctuation">,</span>    <span class="token string">"-log=info"</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>注意，<code>clangd</code> 插件跟 <code>C/C++</code> 插件是冲突的，如果使用 <code>clangd</code> 的功能，需要禁用 <code>C/C++</code> 插件。</p><pre class="line-numbers language-json" data-language="json"><code class="language-json"><span class="token property">"C_Cpp.intelliSenseEngine"</span><span class="token operator">:</span> <span class="token string">"Disabled"</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>另外，在使用 <code>Remote - SSH</code> 连接上远程 Linux 虚拟机后，需要同时在远程 Linux 虚拟机上安装 <code>clangd</code> 插件，根据 <code>Extensions</code> 侧边栏 <code>clangd</code> 插件的提示按钮 <code>Install in SSH: 192.168.x.x</code> 点击安装即可（可能安装不成功，看后面手动安装步骤）。安装好后，拷贝 <code>clangd</code> 插件的配置到远程 Linux 虚拟机上的 <code>clangd</code> 上，同时配置远程 Linux 虚拟机上安装的 <code>clangd</code> 的可执行文件路径。</p><img src="/2022/04/04/vscode-remote-ssh-clangd-linux-nei-he-yuan-ma-yue-du-huan-jing-da-jian/image-20220404115705791.png" class="" title="image-20220404115705791"><h4 id="手动在远程-Linux-虚拟机上安装-clangd"><a href="#手动在远程-Linux-虚拟机上安装-clangd" class="headerlink" title="手动在远程 Linux 虚拟机上安装 clangd"></a>手动在远程 Linux 虚拟机上安装 <code>clangd</code></h4><ol><li><p>直接在 github 发布页面上下载 <code>clangd</code> 的二进制包，我下载的是 <code>13.0.0</code> 版本的 <code>clangd</code> ： <a href="https://github.com/clangd/clangd/releases/tag/13.0.0">https://github.com/clangd/clangd/releases/tag/13.0.0</a></p></li><li><p>拷贝二进制包到 Linux 安装目录，解压即可。</p><pre class="line-numbers language-sh" data-language="sh"><code class="language-sh">unzip clangd-linux-13.0.0.zip<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>在解压后的文件夹中找到二进制文件 <code>clangd</code> 的文件路径，并在 vscode 中配置远程 Linux 虚拟机上安装的 <code>clangd</code> 的可执行文件路径。（如上所述）</p></li></ol><h3 id="3、生成-clangd-需要的配置文件-compile-commands-json"><a href="#3、生成-clangd-需要的配置文件-compile-commands-json" class="headerlink" title="3、生成 clangd 需要的配置文件 compile_commands.json"></a>3、生成 <code>clangd</code> 需要的配置文件 <code>compile_commands.json</code></h3><h4 id="安装-bear"><a href="#安装-bear" class="headerlink" title="安装 bear"></a>安装 bear</h4><ol><li>直接在 <a href="https://koji.fedoraproject.org/koji/">https://koji.fedoraproject.org/koji/</a> 下载合适的 bear 版本的 rpm 包，我下载的版本 <code>bear-2.4.4-1.fc31</code> 。</li><li>将 rpm 包拷到 Linux 虚拟机上，通过 <code>yum install bear-2.4.4-1.fc31.x86_64.rpm</code> 安装即可。</li></ol><h4 id="编译内核代码生成compile-commands-json"><a href="#编译内核代码生成compile-commands-json" class="headerlink" title="编译内核代码生成compile_commands.json"></a>编译内核代码生成<code>compile_commands.json</code></h4><p>参考文档：<a href="https://www.cyberciti.biz/tips/compiling-linux-kernel-26.html">https://www.cyberciti.biz/tips/compiling-linux-kernel-26.html</a></p><ol><li><p>下载指定的内核版本的源码包，可以直接去官网下载：<a href="https://www.kernel.org/">https://www.kernel.org/</a></p></li><li><p>解压源码包 <code>tar -zxvf kernel.tar.gz</code> ，并进入源码包的根目录。</p></li><li><p>可以直接拷贝当前Linux虚拟机的内核配置文件（<code>cp -v /boot/config-$(uname -r) .config</code>），或直接使用 <code>make menuconfig</code> 来配置内核支持的特性和模块配置。</p></li><li><p>安装编译依赖的工具包</p><pre class="line-numbers language-sh" data-language="sh"><code class="language-sh">yum group install &quot;Development Tools&quot;yum install ncurses-devel bison flex elfutils-libelf-devel openssl-devel<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li><li><p>使用 <code>bear</code> 编译内核，执行 <code>bear make -j 8</code></p></li><li><p>编译完成后，会在源码包的根目录下生成 <code>compile_commands.json</code> 文件。</p></li></ol><h3 id="4、通过-vscode-阅读内核源码，可自由跳转了"><a href="#4、通过-vscode-阅读内核源码，可自由跳转了" class="headerlink" title="4、通过 vscode 阅读内核源码，可自由跳转了"></a>4、通过 vscode 阅读内核源码，可自由跳转了</h3><video src="/2022/04/04/vscode-remote-ssh-clangd-linux-nei-he-yuan-ma-yue-du-huan-jing-da-jian/clangd-效果图-2022-04-04.mp4" type='video/mp4' controls='controls'  width='100%' height='100%'></video>]]></content>
      
      
      <categories>
          
          <category> 环境 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vscode阅读Linux内核源码 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Go语言：select语句</title>
      <link href="2022/01/16/go-yu-yan-select-yu-ju/"/>
      <url>2022/01/16/go-yu-yan-select-yu-ju/</url>
      
        <content type="html"><![CDATA[<p>[toc]</p><h2 id="Go语言：select语句"><a href="#Go语言：select语句" class="headerlink" title="Go语言：select语句"></a>Go语言：select语句</h2><h3 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h3><p>功能：select 随机执行一个可运行的 case。如果没有 case 可运行，它将阻塞，直到有 case 可运行。</p><p>语法：</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">select</span> <span class="token punctuation">&#123;</span><span class="token keyword">case</span> clauseA<span class="token punctuation">:</span>    statementA<span class="token keyword">case</span> clauseB<span class="token punctuation">:</span>    statementB<span class="token keyword">default</span><span class="token punctuation">:</span>    statementC<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>说明：</p><ul><li>case 中表达式必须是 Channel 收发操作。</li><li>无论哪一个表达式返回，都会立刻执行 case 中的代码。</li><li>当 select 中两个 case 同时被触发时，会随机执行其中一个，从而避免饥饿问题发生。</li><li>default 语句：提供非阻塞的收发的特性。若存在可收发的 Channel ，直接处理该 case 的语句；否则，执行 default 中的语句。</li></ul><p>select 能够让 Goroutine 同时等待多个 Channel 可读或可写，在多个文件或者 Channel 状态改变之前，select 会一直阻塞当前线程或 Goroutine 。</p><h3 id="select-的几种使用场景"><a href="#select-的几种使用场景" class="headerlink" title="select 的几种使用场景"></a>select 的几种使用场景</h3><ol><li><p>阻塞操作</p><p>使用空的 select 语句，会直接阻塞当前 Goroutine，导致 Goroutine 进入无法被唤醒的永久休眠状态。</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">example</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">select</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li><li><p>单一管道</p><p>select 中只包含一个 case ，编译器会将 select 改写成 if 条件语句。若 case 中 Channel 是空指针时，会直接挂起当前 Goroutine 并陷入永久休眠。</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">example</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    c <span class="token operator">:=</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token keyword">chan</span> <span class="token builtin">string</span><span class="token punctuation">)</span>        <span class="token keyword">go</span> <span class="token keyword">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        time<span class="token punctuation">.</span><span class="token function">Sleep</span><span class="token punctuation">(</span>time<span class="token punctuation">.</span>Second<span class="token punctuation">)</span>        c <span class="token operator">&lt;-</span> <span class="token string">"one message"</span>    <span class="token punctuation">&#125;</span>        <span class="token keyword">select</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">case</span> msg <span class="token operator">:=</span> <span class="token operator">&lt;-</span> c<span class="token punctuation">:</span>        fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"received"</span><span class="token punctuation">,</span> msg<span class="token punctuation">)</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">// 等价于</span>    <span class="token comment">// if msg := &lt;- c &#123;</span>    <span class="token comment">//     fmt.Println("received", msg)</span>    <span class="token comment">// &#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>非阻塞操作：</p><p>select中包含多个case，且其中一个是 default 语句。若不存在可收发的 Channel ，直接执行 default 中的语句。</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">example</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    c <span class="token operator">:=</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token keyword">chan</span> <span class="token builtin">string</span><span class="token punctuation">)</span>        <span class="token keyword">select</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">case</span> msg <span class="token operator">:=</span> <span class="token operator">&lt;-</span> c<span class="token punctuation">:</span>        fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"received"</span><span class="token punctuation">,</span> msg<span class="token punctuation">)</span>    <span class="token keyword">default</span><span class="token punctuation">:</span>        fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"no message received"</span><span class="token punctuation">)</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ol><h3 id="编译器对-select-的处理"><a href="#编译器对-select-的处理" class="headerlink" title="编译器对 select 的处理"></a>编译器对 select 的处理</h3><p>编译器对 select 语句的一般处理流程：</p><ol><li>将所有 case 转换成包含 Channel 以及类型等信息的 <code>runtime.scase</code> 结构体。</li><li>调用 <code>runtime.selectgo</code> 从多个就绪的 Channel 中选择一个可执行的 <code>runtime.scase</code> 结构体。</li><li>通过 for 循环生成一组 if 语句，在语句中判断自己是不是被选中的 case 。</li></ol><p>随机执行的关键运行时函数：<code>runtime.selectgo</code> ，它的执行步骤为，</p><ol><li>确定 case 的处理顺序<ul><li>轮询顺序：通过 <code>runtime.fastrandom</code> 函数引入随机性。</li><li>加锁顺序：按照 Channel 的地址排序后确定加锁顺序。</li></ul></li><li>根据轮询顺序遍历所有的 case ，查看是否有可立即处理的 Channel 。<ul><li>如果存在，直接获取 case 对应的索引并返回</li><li>否则，创建 <code>runtime.sudog</code> 结构体，并将当前 Goroutine 加入到所有相关的 Channel 收发队列，并调用 <code>runtime.gopark</code> 挂起当前 Goroutine ，等待调度器的唤醒。</li></ul></li><li>当调度器唤醒当前 Goroutine 时，会再次按照加锁顺序遍历所有的 case ，从中查找需要被处理的 <code>runtime.sudog</code> 对应的索引。</li></ol><p>select 关键字是 Go 语言特有的控制结构，需要编译器和运行时函数共同实现。</p>]]></content>
      
      
      <categories>
          
          <category> golang </category>
          
      </categories>
      
      
        <tags>
            
            <tag> go </tag>
            
            <tag> select </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>linked-list-cycle-ii</title>
      <link href="2021/05/05/linked-list-cycle-ii/"/>
      <url>2021/05/05/linked-list-cycle-ii/</url>
      
        <content type="html"><![CDATA[<p>[toc]</p><p>Leetcode链接：<a href="https://leetcode-cn.com/problems/linked-list-cycle-ii/">https://leetcode-cn.com/problems/linked-list-cycle-ii/</a></p><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定一个链表，返回链表开始入环的第一个节点。 如果链表无环，则返回 null。</p><p>为了表示给定链表中的环，我们使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。 如果 pos 是 -1，则在该链表中没有环。注意，pos 仅仅是用于标识环的情况，并不会作为参数传递到函数中。</p><p>说明：不允许修改给定的链表。</p><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>分两个步骤，</p><ul><li>首先通过快慢指针的方法判断链表是否有环；</li><li>接下来如果有环，则寻找入环的第一个节点。</li></ul><p>判断链表是否有环很简单，如果快指针为 null 时，则链表无环；否则有环。</p><p>如果有环，则寻找入环的第一个节点，具体的方法为，</p><p>首先假定链表起点到入环的第一个节点A的长度为a【未知】，到快慢指针相遇的节点B的长度为（a + b）【这个长度是已知的】。</p><img src="/2021/05/05/linked-list-cycle-ii/image-20210505230754000.png" class="" title="image-20210505230754000"><p>现在我们想知道a的值，注意到快指针 p_fast 始终是慢指针p走过长度的2倍，所以慢指针 p_slow 从B继续走（a + b）又能回到B点，如果只走a个长度就能回到节点A。</p><img src="/2021/05/05/linked-list-cycle-ii/image-20210505230537824.png" class="" title="image-20210505230537824"><p>但是a的值是不知道的，解决思路是曲线救国，注意到起点到A的长度是a，那么可以用一个从起点开始的新慢指针 p_slow2 和从节点B开始的慢指针 p_slow 同步走，相遇的地方必然是入环的第一个节点A。 </p><img src="/2021/05/05/linked-list-cycle-ii/image-20210505230632200.png" class="" title="image-20210505230632200"><h2 id="编码实现"><a href="#编码实现" class="headerlink" title="编码实现"></a>编码实现</h2><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">/** * Definition for singly-linked list. * class ListNode &#123; *     int val; *     ListNode next; *     ListNode(int x) &#123; *         val = x; *         next = null; *     &#125; * &#125; */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">public</span> <span class="token class-name">ListNode</span> <span class="token function">detectCycle</span><span class="token punctuation">(</span><span class="token class-name">ListNode</span> head<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>head <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span>            <span class="token keyword">return</span> <span class="token keyword">null</span><span class="token punctuation">;</span>                <span class="token comment">// 步骤一：使用快慢指针判断链表是否有环</span>        <span class="token class-name">ListNode</span> p <span class="token operator">=</span> head<span class="token punctuation">,</span> p2 <span class="token operator">=</span> head<span class="token punctuation">;</span>        <span class="token keyword">boolean</span> hasCycle <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>p2<span class="token punctuation">.</span>next <span class="token operator">!=</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> p2<span class="token punctuation">.</span>next<span class="token punctuation">.</span>next <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            p <span class="token operator">=</span> p<span class="token punctuation">.</span>next<span class="token punctuation">;</span>            p2 <span class="token operator">=</span> p2<span class="token punctuation">.</span>next<span class="token punctuation">.</span>next<span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>p <span class="token operator">==</span> p2<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                hasCycle <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>                <span class="token keyword">break</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>                <span class="token comment">// 步骤二：若有环，找到入环开始的节点</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>hasCycle<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token class-name">ListNode</span> q <span class="token operator">=</span> head<span class="token punctuation">;</span>            <span class="token keyword">while</span> <span class="token punctuation">(</span>p <span class="token operator">!=</span> q<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                p <span class="token operator">=</span> p<span class="token punctuation">.</span>next<span class="token punctuation">;</span>                q <span class="token operator">=</span> q<span class="token punctuation">.</span>next<span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>            <span class="token keyword">return</span> q<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span> <span class="token keyword">else</span>             <span class="token keyword">return</span> <span class="token keyword">null</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 算法与数据结构 </category>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 快慢指针 </tag>
            
            <tag> 链表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hexo上markdown图片路径与Typora保持一致</title>
      <link href="2021/05/05/hexo-shang-markdown-tu-pian-lu-jing-yu-typora-bao-chi-yi-zhi/"/>
      <url>2021/05/05/hexo-shang-markdown-tu-pian-lu-jing-yu-typora-bao-chi-yi-zhi/</url>
      
        <content type="html"><![CDATA[<p>Typora是一款很好用的markdown语法编辑器，我希望使用Typora写好博客后，直接通过hexo部署到个人博客主页上面去。但有个问题是，如果markdown文件里面有图片路径时，在部署到hexo上时需要重新修改图片路径，否则会有问题。每次手动修改显然很麻烦，因此需要看看hexo是否有比较友好的支持。</p><p>Typora本地插入图片的路径有两种方式：一个是绝对路径，一个是相对路径（相对于当前文件所在的路径）。</p><p>Hexo通过<code>hexo-renderer-marked</code>插件实现了对markdown语法的支持，其中默认插入图片的方式为 <code>![](/images/image.jpg)</code> ，它是一个相对路径（相对于Hexo工作目录下的 <code>source</code> 文件夹）的方式。</p><p>首先，如果Typora使用本地的绝对路径插入图片，那么在执行 <code>hexo g</code> 时需要将本地的绝对路径转换成对应的相对路径，这个目前暂未看到有相关的插件实现。</p><p>其次，如果Typora使用相对路径插入图片，问题在于Typora和Hexo所相对的路径是不一致的。对此，Hexo提供了一个更组织化的方式来管理资源，可以通过将 <code>_config.yml</code> 配置文件中的 <code>post_asset_folder</code> 选项设置为 <code>true</code> 来打开。</p><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"><span class="token comment"># _config.yml</span><span class="token key atrule">post_asset_folder</span><span class="token punctuation">:</span> <span class="token boolean important">true</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>该功能打开后，Hexo将会在你每一次通过 <code>hexo new [layout] &lt;title&gt;</code> 命令创建新文章时自动创建一个文件夹。这个资源文件夹名与这个文章文件名相同。将所有与你的文章有关的资源（如图片）放在这个关联文件夹中之后，你可以通过相对路径来引用它们。如，我使用 <code>hexo new mytitle</code> 创建了一篇文章 <code>mytitle.md</code> ，会同时在该文章文件所在的路径上创建文件夹 <code>mytitle/</code>，我们在该文件夹里面添加图片 <code>mytitle/my.png</code>，这时我们在 <code>mytitle.md</code> 文件中插入该图片的方式为 <code>![](my.png)</code> 就可以了。</p><p>跟Typora很接近了，但Typora需要的是 <code>&#123;% asset_img my.png  %&#125;</code> （此处显示有个bug，Hexo自动将满足 <code>mytitle/my.png</code> 格式的图片路径转换成Hexo图片标签插件了，而实际上这里我用了反引号，按理说不应该转义的。。。），即</p><pre class="line-numbers language-none"><code class="language-none">![](mytitle&#x2F;my.png)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>因此还需要一步转换：<code>mytitle/my.png  -&gt; my.png</code> 。幸运的是，Hexo提供了一款插件 <code>hexo-image-link</code> 来实现这一步转换，在Hexo根目录下执行 <code>npm install hexo-image-link --save</code> 安装该插件即可，无需额外的配置。</p><p>至此，问题解决！总结下来操作上只需要做两个步骤即可：</p><ol><li><p>安装插件 <code>hexo-image-link</code></p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">npm install hexo-image-link --save<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>打开Hexo资源管理配置开关</p><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"><span class="token comment"># _config.yml</span><span class="token key atrule">post_asset_folder</span><span class="token punctuation">:</span> <span class="token boolean important">true</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li></ol><p>最后，上一个例子，在本篇博客最后编辑一行，</p><pre class="line-numbers language-none"><code class="language-none">&#x2F;&#x2F; source&#x2F;_posts&#x2F;2021&#x2F;05&#x2F;05&#x2F;Hexo上markdown图片路径与Typora保持一致.md![](Hexo上markdown图片路径与Typora保持一致&#x2F;古剑3.jpg)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>接下来你可以看到本篇博客显示如下图片，</p><img src="/2021/05/05/hexo-shang-markdown-tu-pian-lu-jing-yu-typora-bao-chi-yi-zhi/%E5%8F%A4%E5%89%913.jpg" class="">]]></content>
      
      
      <categories>
          
          <category> 环境 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 博客 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
