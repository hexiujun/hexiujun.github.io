[{"title":"设计模式之适配器模式","date":"2022-05-07T14:37:46.000Z","path":"2022/05/07/she-ji-mo-shi-zhi-gua-pei-qi-mo-shi/","text":"课程笔记：极客时间—设计模式之美 适配器模式解决的问题：适配器模式就是用来做适配的，它将不兼容的接口转换为可兼容的接口，让原本由于接口不兼容而不能一起工作的类可以一起工作。 2种实现方式适配器模式有两种实现方式：类适配器和对象适配器。其中，类适配器使用继承关系来实现，对象适配器使用组合关系来实现。 类适配器类适配器的代码实现如下。 public interface ITarget &#123; void f1(); void f2(); void fc(); &#125; public class Adaptee &#123; public void fa() &#123;&#125; public void fb() &#123;&#125; public void fc() &#123;&#125; &#125; public class Adaptor extends Adaptee implements ITarget &#123; public void f1() &#123; super.fa(); &#125; public void f2() &#123; // 重新实现 f2() &#125; // fc() 不需要实现，直接继承自 Adaptee &#125; 对象适配器对象适配器的代码实现如下。 public interface ITarget &#123; void f1(); void f2(); void fc(); &#125; public class Adaptee &#123; public void fa() &#123;&#125; public void fb() &#123;&#125; public void fc() &#123;&#125; &#125; public class Adaptor implements ITarget &#123; private Adaptee adaptee; public Adaptor(Adaptee adaptee) &#123; this.adaptee = adaptee; &#125; public void f1() &#123; adaptee.fa(); &#125; public void f2() &#123; // 重新实现 f2() &#125; public void fc() &#123; adaptee.fc(); &#125; &#125; 如何选择？判断标准： Adaptee 接口的个数 Adaptee 和 ITarget 的契合程度 如果 Adaptee 接口并不多，那两种实现方式都可以。 如果 Adaptee 接口很多，而且 Adaptee 和 ITarget 的接口定义大部分都相同，则推荐使用类适配器，因为 Adaptor 复用父类 Adaptee 的接口，代码量更少。 如果 Adaptee 接口很多，而且 Adaptee 和 ITarget 的接口定义大部分都不相同，则推荐使用对象适配器，因为组合结构相对于继承更加灵活。 5种常见的应用场景一般来说，适配器模式可以看作一种“补偿模式”，用来补救设计上的缺陷。适配器模式的应用场景是“接口不兼容”。 封装有缺陷的接口设计 假设我们依赖的外部系统在接口设计方面有缺陷（比如包含大量静态方法），引入后会影响到我们自身代码的可测试性。为了隔离设计上的缺陷，我们希望对外部系统提供的接口进行二次封装，抽象出更好的接口设计，这个时候就可以使用适配器模式了。 例： // 这个类来自外部 sdk ，我们无权修改它的代码 public class CD &#123; public static void staticFunc1() &#123;&#125; public void uglyNamingFunc2() &#123;&#125; public void tooManyParamsFunc3(int paramA, int paramB, ...) &#123;&#125; public void lowPerformanceFunc4() &#123;&#125; &#125; // 使用适配器模式进行重构 public interface ITarget &#123; void func1(); void func2(); void func3(ParamsWrapperDefinition paramsWrapper); void func4(); &#125; public class CDAdaptor extends CD implements ITarget &#123; public void func1() &#123; super.staticFunc1(); &#125; public void func2() &#123; super.uglyNamingFunc2(); &#125; public void func3(ParamsWrapperDefinition paramsWrapper) &#123; super.tooManyParamsFunc3(paramsWrapper.getParamA(), ...); &#125; public func4() &#123; // 重新实现 lowPerformanceFunc4() &#125; &#125; 统一多个类的接口设计 某个功能的实现依赖多个外部系统（或者说类）。通过适配器模式，将它们的接口适配为统一的接口定义，然后我们就可以使用多态的特性来复用代码逻辑。 例：假设我们的系统要对用户输入的文本内容做敏感词过滤，为了提高过滤的召回率，我们引入了多个第三方过滤系统，依此对用户输入的内容进行过滤。但是每个系统提供的过滤接口都是不同的，这意味着我们没法复用一套逻辑来调用各个系统。这时，可以使用适配器模式，将所有过滤系统的接口适配为统一的接口定义，进而可以复用调用敏感词过滤的代码。代码示例如下， public class ASensitiveWordsFilter &#123; public String filterSexyWords(String text) &#123;&#125; public String filterPoliticalWords(String text) &#123;&#125; &#125; public class BSensitiveWordsFilter &#123; public String filter(String text) &#123;&#125; &#125; public class CSensitiveWordsFilter &#123; public String filter(String text, String mask) &#123;&#125; &#125; // 未使用适配器模式之前的代码：代码的可测试性、扩展性不好 public class RiskManagement &#123; private ASensitiveWordsFilter aFilter; private BSensitiveWordsFilter bFilter; private CSensitiveWordsFilter cFilter; public String filterSensitiveWords(String text) &#123; String maskedText = aFilter.filterSexyWords(text); maskedText = aFilter.filterPoliticalWords(text); maskedText = bFilter.filter(text); maskedText = cFilter.filter(text, \"***\"); return maskedText; &#125; &#125; // 使用适配器模式进行重构 public interface ISensitiveWordsFilter &#123; String filter(String text); &#125; public class ASensitiveWordsFilterAdaptor implements ISensitiveWordsFilter &#123; private ASensitiveWordsFilter aFilter; public String filter(String text) &#123; String maskedText = aFilter.filterSexyWords(text); maskedText = aFilter.filterPoliticalWords(text); return maskedText; &#125; &#125; public class BSensitiveWordsFilterAdaptor implements ISensitiveWordsFilter &#123; private BSensitiveWordsFilter bFilter; public String filter(String text) &#123; String maskedText = bFilter.filter(text); return maskedText; &#125; &#125; // 省略 CSensitiveWordsFilterAdaptor 的实现 // 扩展性更好，更加符合开闭原则，添加新的过滤器时，这个类完全不需要修改； // 可测试性好，因为它基于接口而非实现编程。 public class RiskManagement &#123; private List&lt;ISensitiveWordsFilter> filters; public void addSensitiveWordsFilter(ISensitiveWordsFilter filter) &#123; filters.add(filter); &#125; public String filterSensitiveWords(String text) &#123; String maskedText = text; for (ISensitiveWordsFilter filter: filters) &#123; filter.filter(maskedText); &#125; return maskedText; &#125; &#125; 替换依赖的外部系统 当我们把项目种依赖的一个外部系统替换为另一个外部系统的时候，使用适配器模式，可以减少对代码的改动。 例： // 外部系统 A public interface IA &#123; void fa(); &#125; public class A implements IA &#123; public void fa() &#123;&#125; &#125; // 在我们的项目中，外部系统 A 的使用示例 public class Demo &#123; private IA a; public Demo(IA a) &#123; this.a = a; &#125; &#125; Demo d = new Demo(new A()); // 将外部系统 A 替换成外部系统 B public class BAdaptor implements IA &#123; private B b; public BAdaptor(B b) &#123; this.b = b; &#125; public void fa() &#123; b.fb(); &#125; &#125; // 借助 BAdaptor ，Demo 的代码中，调用 IA 接口的地方无需改动， // 只需要将 BAdaptor 如下注入到 Demo 即可。 Demo d = new Demo(new BAdaptor(new B())); 兼容老版本接口 在做版本升级的时候，对于一些要废弃的接口，我们不直接将其删除，而是暂时保留，并且标注为 deprecated，并将内部实现逻辑委托为新的接口实现。这样做的好处是，让使用它的项目有个过渡期，而不是强制进行代码修改。这也可以粗略的看作适配器模式的一个应用场景。 例：JDK2.0 对 JDK1.0 中的一个遍历集合容器的类 Enumeration 进行了重构，将它改名为 Iterator 类，并对它的代码实现做了优化。为了前向兼容，JDK2.0 保留了 Enumeration 类，并将其实现替换为直接调用 Iterator 。 public class Collections &#123; public static Enumeration enumeration(final Collection c) &#123; return new Enumeration() &#123; Iterator i = c.iterator(); public boolean hasMoreElements() &#123; return i.hasNext(); &#125; public Object nextElement() &#123; return i.next(); &#125; &#125; &#125; &#125; 适配不同格式的数据 适配器模式主要用于接口的适配，实际上，它还可以用在不同格式的数据之间的适配。 例：Java 中的 Arrays.asList() 也可以看作一种数据适配器，将数组类型的数据转化为集合容器类型。 List&lt;String> stooges = Arrays.asList(\"Larry\", \"Moe\"); 案例剖析：slf4j 日志框架slf4j 日志框架，提供了一套打印日志的统一接口规范。不过，它只定义了接口，并没有提供具体的实现，因此需要配合其他日志框架（log4j、logback…）来使用。 由于 slf4j 的出现晚于 log4j 等日志框架，所以这些日志框架也不可能牺牲掉版本兼容性，将接口改造成符合 slf4j 接口规范。 因此，slf4j 还提供了针对不同日志框架的适配器。对不同日志框架的接口进行二次封装，适配成统一的 slf4j 接口定义。 具体的代码示例如下： // slf4j 统一的接口定义 package org.slf4j; public interface Logger &#123; public boolean isTraceEnabled(); public void trace(String msg); // ... public boolean isDebugEnabled(); public void debug(string msg); // ... &#125; // log4j 日志框架的适配器 // 其中 LocationAwareLogger 继承自 Logger package org.slf4j.impl; public final class Log4jLoggerAdaptor implements LocationAwareLogger &#123; final transient org.apache.log4j.Logger logger; public boolean isDebugEnabled() &#123; return logger.isDebugEnabled(); &#125; public void debug(String msg) &#123; logger.log(FQCN, Level.DEBUG, msg, null); &#125; // ... &#125; 适配器模式类图 对比其他几种设计模式代理模式、桥接模式、装饰器模式、适配器模式，这4种模式是比较常用的结构型设计模式。 它们的相同点： 代码结构非常相似； 它们都可以称为 Wrapper 模式，也就是通过 Wrapper 类二次封装原始类。 它们的不同点：解决的问题、应用场景不同。 代理模式：在不改变原始类接口的条件下，为原始类定义一个代理类，主要目的是控制访问，而非加强功能，这是它跟装饰器模式最大的不同。 桥接模式：目的是将接口部分和实现部分分离，从而让它们可以较为容易、也相对独立的变化。 装饰器模式：在不改变原始类接口的条件下，对原始类功能进行增强，并且支持多个装饰器的嵌套使用。 适配器模式：是一种事后的补救策略。适配器提供跟原始类不同的接口，而代理模式、装饰器模式提供的都是跟原始类相同的接口。","tags":[{"name":"设计模式","slug":"设计模式","permalink":"https://algorithmofdish.tech/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"name":"适配器模式","slug":"适配器模式","permalink":"https://algorithmofdish.tech/tags/%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F/"}]},{"title":"设计模式学习导读","date":"2022-05-07T12:48:29.000Z","path":"2022/05/07/she-ji-mo-shi-xue-xi-dao-du/","text":"课程笔记：极客时间—设计模式之美 设计模式学习导读为什么要学习设计模式？ 应对面试中的设计模式相关问题 告别写被别人吐槽的烂代码 提高复杂代码的设计和开发能力 让读源码、学框架事半功倍 为你的职场发展做铺垫 有些能力，要早点锻炼；有些东西，要早点知道；有些书，要早点读。这样在你后面的生活、工作、学习中，才能一直发挥作用。不要等到好多年后，看到了，才恍然大悟，后悔没有早点去学、去看。 设计模式作为一门与编程、开发有着直接关系的基础知识，是你现在就要开始学习的。早点去学习，以后的项目就都可以拿来锻炼，每写一行代码都是对内功的利用和加深，是可以受益一整个职业生涯的事情。 从哪些维度评判代码质量的好坏？写出好代码的前提：能够辨别代码写得”好“还是”烂“。 评价代码质量好坏的认知： 需要综合各种因素来进行评价。 不同的评价维度也并不是完全独立的，有些是具有包含关系、重叠关系或者可以互相影响的。 各种评价维度也并不是非黑即白的。 对一段代码的质量评价，常常有很强的主观性。 7个最常用的代码评价标准 可维护性（Maintainability） 什么是代码的可维护性？ “维护”主要包括修改bug、修改老的代码、添加新的代码之类的工作。 “代码易维护”是指：在不破坏原有代码设计、不引入新的bug的情况下，能够快速地修改或者添加代码。 “代码不易维护”是指：修改或者添加代码需要冒着极大的引入新bug的风险，并且需要花费很长的时间才能完成。 可维护性的重要性：对于一个项目来说，维护代码的时间远远大于编写代码的时间。工程师大部分的时间可能都是花在修修bug、改改老的功能逻辑、添加一些新的功能逻辑之类的工作上。 如何量化可维护性？ 代码可维护性的好坏是一个比较主观的评价标准，如： 代码的可读性好、简洁、可扩展性好，就会使得代码易维护； 更细化地讲，如果代码分层清晰、模块化好、高内聚低耦合、遵从基于接口而非实现编程的设计原则等等，那就意味着代码易维护； 代码的易维护性还跟项目代码量的多少、业务的复杂程度、技术复杂程度、文档是否全面、团队成员的开发水平等诸多因素有关； 可读性（Readability） 代码的可读性应该是评价代码质量最重要的指标之一。 如何评价一段代码的可读性？ 代码是否符合编程规范 命名是否达意 注释是否详尽 函数是否长短合适 模块划分是否清晰 是否符合高内聚低耦合 …… 一个主观的评价手段：code review。如果你的同事可以轻松地读懂你写的代码，那说明你的代码可读性很好；如果同事在读你写的代码时，有很多疑问，那就说明你的代码可读性有待提高了。 可扩展性（Extensibility） 代码的可扩展性也是一个评价代码质量非常重要的标准。 它表示我们的代码应对未来需求变化的能力。 代码的可扩展性是指：我们在不修改或少量修改原有代码的情况下，通过扩展的方式添加新的功能代码。 灵活性（Flexibility） 如何理解灵活性？ 灵活性是一个挺抽象的评价标准，要给它下个定义很难。我们可以通过下面的几个场景来思考什么是灵活性。 场景1：当我们添加一个新的功能代码的时候，原有代码已经预留好了扩展点，我们不需要修改原有的代码，只要在扩展点上添加新的代码即可。（易扩展、灵活） 场景2：当我们要实现一个功能的时候，发现原有代码中，已经抽象出了很多底层可以复用的模块、类等代码，我们可以拿来直接使用。（易复用、灵活） 场景3：当我们使用某组接口的时候，如果这组接口可以应对各种使用场景，满足各种不同的需求。（易用、灵活） 简洁性（Simplicity） KISS原则：”Keep It Simple, Stupid” 代码简洁、逻辑清晰，也就意味着易读、易维护。 一个偏见：认为简单的代码没有技术含量。实际上，思从深而行从简，真正的高手能云淡风轻地用最简单的方法解决最复杂的问题。这也是一个编程老手跟编程新手的本质区别之一。 可复用性（Reusability） 代码的可复用性可以简单地理解为，尽量减少重复代码的编写，复用已有的代码。 如何提高代码的可复用性？ 使用继承、多态 使用单一职责原则 解耦、高内聚、模块化 应用DRY设计原则 可测试性（Testability） 代码可测试性的好坏，能从侧面上非常准确地反映代码质量的好坏。 代码的可测试性差，比较难写单元测试，那基本上就能说明代码设计得有问题。 如何才能写出高质量的代码？如何写出高质量的代码，也就等同于，如何写出易维护、易读、易扩展、灵活、简洁、可复用、可测试的代码。 要写出满足这些评价标准的高质量代码，我们需要掌握一些更加细化、更加能落地的编程方法论。包括： 面向对象设计思想 设计原则 设计模式 编程规范 重构技巧 编程方法论面向对象面向对象因为其具有丰富的特性（封装、抽象、继承、多态），可以实现很多复杂的设计思路，是很多设计原则、设计模式编码实现的基础。 面向对象编程的相关知识点： 面向对象四大特性：封装、抽象、继承、多态 面向对象编程与面向过程编程的区别和联系 面向对象分析、面向对象设计、面向对象编程 接口与抽象类的区别以及各自的应用场景 多用组合少用继承的设计思想 面向过程的贫血模型和面向对象的充血模型 设计原则设计原则是指导我们代码设计的一些经验总结。 对于每一种设计原则，我们需要掌握它的设计初衷、能解决哪些编程问题，有哪些应用场景。 几个常用的设计原则： SOLID原则——SRP单一职责原则 SOLID原则——OCP开闭原则 SOLID原则——LSP里氏替换原则 SOLID原则——ISP接口隔离原则 SOLID原则——DIP依赖倒置原则 DRY原则、KISS原则、YAGNI原则、LOD原则 设计模式设计模式是针对软件开发中经常遇到的一些设计问题，总结出来的一套解决方案或者设计思路。 设计模式相对于设计原则来说，没那么抽象，而且大部分都不难理解，代码实现也并不复杂。这一块的学习难点是了解它们都能解决哪些问题，掌握典型的应用场景，并且懂得不过度应用。 23中经典的设计模式： 创建型模式 常用的有：单例模式、工厂模式（工厂方法模式、抽象工厂模式）、建造者模式 不常用的有：原型模式 结构型模式 常用的有：代理模式、桥接模式、装饰器模式、适配器模式 不常用的有：门面模式、组合模式、享元模式 行为型模式 常用的有：观察者模式、模板模式、策略模式、职责链模式、迭代器模式、状态模式。 不常用的有：访问者模式、备忘录模式、命令模式、解释器模式、中介模式。 对于常用的设计模式，我们要多花点时间理解掌握。对于不常用的设计模式，我们只需要稍微了解即可。 编程规范编程规范主要解决的是代码的可读性问题。 编程规范相对于设计原则、设计模式，更加具体、更加偏重代码细节。 可直接看经典书籍：《重构》、《代码整洁之道》 代码重构软件开发是一个不停迭代的过程，因此没有一劳永逸的设计。随着需求的变化，代码的不停堆砌，原有的设计必定会存在这样或那样的问题。 重构是软件开发中非常重要的一个环节。持续重构是保持代码质量不下降的有效手段，能有效避免代码腐化到无可救药的地步。 重构的工具包括： 设计思想 设计原则 设计模式 编程规范 重构相关的知识点 重构的目的、对象、时机、方法 保证重构不出错的技术手段：单元测试和代码的可测试性 两种不同规模的重构：大重构（大规模高层次）和小重构（小规模低层次） 学习重构，不仅仅要掌握一些重构技巧、套路，更重要的是建立持续重构的意识，把重构当作开发的一部分，融入到日常的开发中。 五者之间的联系 面向对象编程因为其具有丰富的特性，可以实现很多复杂的设计思路，是很多设计原则、设计模式等编码实现的基础。 设计原则是指导我们代码设计的一些经验总结，对于某些场景下，是否应该应用某种设计模式，具有指导意义。 设计模式是针对软件开发中经常遇到的一些设计问题，总结出来的一套解决方案或者设计思路。应用设计模式的主要目的是提高代码的可扩展性。从抽象程度来说，设计原则比设计模式更抽象，设计模式更加具体、更加可执行。 编程规范主要解决的是代码的可读性问题。编程规范相较于设计原则、设计模式，更加具体、更加偏重代码细节、更加能落地。持续的小重构依赖的理论基础主要就是编程规范。 重构作为保持代码质量不下降的有效手段，利用的就是面向对象、设计原则、设计模式、编码规范这些理论。","tags":[{"name":"设计模式","slug":"设计模式","permalink":"https://algorithmofdish.tech/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}]},{"title":"设计模式之装饰器模式","date":"2022-05-07T11:52:33.000Z","path":"2022/05/07/she-ji-mo-shi-zhi-zhuang-shi-qi-mo-shi/","text":"课程笔记：极客时间—设计模式之美 装饰器模式解决的问题：装饰器模式主要解决继承关系过于复杂的问题，通过组合来代替继承。 主要的作用：给原始类添加增强功能。 案例讲解：通过剖析 Java IO 类的设计思想来学习装饰器模式Java IO类库的部分继承关系： 字节流 InputStream（抽象类） PipedInputStream FileInputStream FilterInputStream BufferedInputStream DataInputStream OutputStream（抽象类） 字符流 其中，FileInputStream 是专门用来读取文件流的子类。BufferedInputStream是一个支持带缓存功能的数据读取类，可以提高数据读取的效率。 考虑给 FileInputStream 扩展一个支持带缓存读取的功能，有两种设计方案： 基于继承的设计方案 添加一个继承 FileInputStream 的子类 BufferedFileInputStream 来实现该功能。 该方案的问题：假如我需要再给 PipedInputStream 添加缓存功能，则需要再添加一个继承自 PipedInputStream 的子类 BufferedPipedInputStream ；另外，除了支持缓存读取之外，如果我们还需要对功能进行其他方面的增强，比如 DataInputStream 类（支持按照基本数据类型来读取数据），就需要再继续派生出 DataFileInputStream 、 DataPipedInputStream 等 n 多个子类。依此类推，如果需要附加更多的增强功能（假设有 m 个），那么就会导致组合爆炸（新增 m x n 个子类），类继承结构变得无比复杂，代码既不好扩展，也不好维护。 基于装饰器模式的设计方案 简而言之，就是“使用组合来替代继承”。 这里给出了部分的代码实现结构： public abstract class InputStream &#123; public int read(byte b[]) throws IOException &#123; return read(b, 0, b.length); &#125; public long skip(long n) throws IOException &#123; //... &#125; &#125; public class BufferedInputStream extends InputStream &#123; protected volatile InputStream in; protected BufferedInputStream(InputStream in) &#123; this.in = in; &#125; // 实现基于缓存的读数据接口 &#125; public class DataInputStream extends InputStream &#123; protected volatile InputStream in; protected DataInputStream(InputStream in) &#123; this.in = in; &#125; // 实现基于读取基本类型数据的接口 &#125; 使用下面的代码，我们就可以分别创建一个支持缓存功能、和支持读取基本数据类型的读取文件流。 InputStream bin = new BufferedInputStream(new FileInputStream(\"/path/to/test.txt\")); InputStream din = new DataInputStream(new FileInputStream(\"/path/to/test.txt\")); 如果总共需要添加 m 个附加功能，那我们只需要创建 m 个继承自 InputStream 的子类即可。 装饰器模式相对于简单的组合关系，还有两个比较特殊的地方。 第一个特殊的地方：装饰器类和原始类继承同样的父类，这样我们可以对原始类“嵌套”多个装饰器类。 比如，下面一段代码，通过对 FileInputStream 嵌套了两个装饰器类，让它既支持缓存读取，又支持按照基本数据类型来读取数据。 InputStream in = new FileInputStream(\"/path/to/test.txt\"); InputStream bin = new BufferedInputStream(in); InputStream din = new DataInputStream(bin); 不得不感叹这样的设计是真的优雅。 第二个特殊的地方：装饰器类是对功能的增强，这也是装饰器模式应用场景的一个重要特点。 这里我们通过对比装饰器模式和代理模式的设计差异来加深认识。 代理模式跟装饰器模式的代码结构很像，它们都是符合“组合关系”的设计。但是，它们的设计意图是不同的。 代理模式中，代理类附加的是跟原始类无关的功能； 装饰器模式中，装饰器类附加的是跟原始类相关的增强功能。 // 代理模式的代码结构（下面的接口可替换成抽象类） public interface IA &#123; void f(); &#125; public class A implements IA &#123; public void f() &#123;&#125; &#125; public class AProxy implements IA &#123; private IA a; public AProxy(IA a) &#123; this.a = a; &#125; public void f() &#123; // 新添加的代理逻辑 a.f(); // 新添加的代理逻辑 &#125; &#125; // 装饰器模式的代码结构（下面的接口可替换成抽象类） public interface IA &#123; void f(); void f2(); &#125; public class A implements IA &#123; public void f() &#123;&#125; public void f2() &#123;&#125; &#125; public class ADecorator implements IA &#123; private IA a; public ADecorator(IA a) &#123; this.a = a; &#125; public void f() &#123; // 功能增强代码 a.f(); // 功能增强代码 &#125; public void f2() &#123; a.f2(); &#125; &#125; 在装饰器模式中，即使对于不需要增强的函数来说，装饰器类还是必须把它重新实现一遍，简单包裹对被装饰类的函数调用。原因也很容易理解，装饰器类既然是对原始类功能的增强，那么原始类已有的功能就必须被继承下来。而这带来了一个问题，增加了重复代码。 聪明的你可能已经想到了解决方案：使用继承。这也是 Java IO 类的设计中，BufferedInputStream 并没有直接继承自 InputStream，而是抽象出了一个装饰器父类 FilterInputStream 的原因所在。这样，装饰器类只需要实现它需要增强的方法就可以了，其他方法继承装饰器父类的默认实现。 public class FilterInputStream extends InputStream &#123; protected volatile InputStream in; protected FilterInputStream(InputStream in) &#123; this.in = in; &#125; public int read(byte b[]) throws IOException &#123; return in.read(b); &#125; public long skip(long n) throws IOException &#123; return in.skip(n); &#125; &#125; 装饰器模式类图","tags":[{"name":"设计模式","slug":"设计模式","permalink":"https://algorithmofdish.tech/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"name":"装饰器模式","slug":"装饰器模式","permalink":"https://algorithmofdish.tech/tags/%E8%A3%85%E9%A5%B0%E5%99%A8%E6%A8%A1%E5%BC%8F/"}]},{"title":"vscode + Remote SSH + clangd Linux内核源码阅读环境搭建","date":"2022-04-04T05:19:04.000Z","path":"2022/04/04/vscode-remote-ssh-clangd-linux-nei-he-yuan-ma-yue-du-huan-jing-da-jian/","text":"1、vscode + Remote SSH 远程连接Linux虚拟机环境说明 vscode运行在Windows环境 Linux虚拟机是在Windows环境下通过VMWare安装 Linux版本：openEuler 22.03 涉及到的软件包安装基本上都是基于 rpm 包安装的 连接配置过程 安装 Remote - SSH 插件 添加远程主机 首先，打开 vscode 命令输入栏（快捷键 F1 或 Ctrl + Shift + P），搜索 Remote-SSH: Connect to Host... ，回车。 在连接窗口中，输入你要远程连接的远程主机（这里是我的Linux虚拟机），输入格式为：user@host，如 root@192.168.0.111 ，回车。 此时会弹出一个新的 vscode 窗口，依此选择远程主机的系统类型（我的是 Linux），输入远程主机的密码，回车。 如果一切正常的话，你将成功连上你的远程主机，此时 vscode 窗口左下角会出现 SSH: 192.168.x.x 表示你连上的远程主机IP。另外，你可以在 explorer 侧边栏点击 OpenFolder ，此时会弹出远程主机的文件目录结构，选择一个文件夹作为你的工作目录即可。 至此，你就可以直接在Windows环境下通过 vscode 操作远程主机上的代码了。 遇到的问题 远程主机一直连不上，打开 vscode 的输出控制台，打印 open failed: administratively prohibited: open failed 字样的错误。 去 vscode 官网，查看 Remote-SSH 插件的问题处理文档：https://code.visualstudio.com/docs/remote/troubleshooting#_troubleshooting-hanging-or-failing-connections ，搜索关键字，找到相应的解决办法。 2、安装 clangd 插件安装 clangd 插件，安装好后在 settings.json 中添加如下 clangd 的配置（可按需扩展）， \"clangd.arguments\": [ \"--compile-commands-dir=$&#123;workspaceFolder&#125;\", \"--background-index\", \"--completion-style=detailed\", \"-log=info\" ], 注意，clangd 插件跟 C/C++ 插件是冲突的，如果使用 clangd 的功能，需要禁用 C/C++ 插件。 \"C_Cpp.intelliSenseEngine\": \"Disabled\" 另外，在使用 Remote - SSH 连接上远程 Linux 虚拟机后，需要同时在远程 Linux 虚拟机上安装 clangd 插件，根据 Extensions 侧边栏 clangd 插件的提示按钮 Install in SSH: 192.168.x.x 点击安装即可（可能安装不成功，看后面手动安装步骤）。安装好后，拷贝 clangd 插件的配置到远程 Linux 虚拟机上的 clangd 上，同时配置远程 Linux 虚拟机上安装的 clangd 的可执行文件路径。 手动在远程 Linux 虚拟机上安装 clangd 直接在 github 发布页面上下载 clangd 的二进制包，我下载的是 13.0.0 版本的 clangd ： https://github.com/clangd/clangd/releases/tag/13.0.0 拷贝二进制包到 Linux 安装目录，解压即可。 unzip clangd-linux-13.0.0.zip 在解压后的文件夹中找到二进制文件 clangd 的文件路径，并在 vscode 中配置远程 Linux 虚拟机上安装的 clangd 的可执行文件路径。（如上所述） 3、生成 clangd 需要的配置文件 compile_commands.json安装 bear 直接在 https://koji.fedoraproject.org/koji/ 下载合适的 bear 版本的 rpm 包，我下载的版本 bear-2.4.4-1.fc31 。 将 rpm 包拷到 Linux 虚拟机上，通过 yum install bear-2.4.4-1.fc31.x86_64.rpm 安装即可。 编译内核代码生成compile_commands.json参考文档：https://www.cyberciti.biz/tips/compiling-linux-kernel-26.html 下载指定的内核版本的源码包，可以直接去官网下载：https://www.kernel.org/ 解压源码包 tar -zxvf kernel.tar.gz ，并进入源码包的根目录。 可以直接拷贝当前Linux虚拟机的内核配置文件（cp -v /boot/config-$(uname -r) .config），或直接使用 make menuconfig 来配置内核支持的特性和模块配置。 安装编译依赖的工具包 yum group install &quot;Development Tools&quot; yum install ncurses-devel bison flex elfutils-libelf-devel openssl-devel 使用 bear 编译内核，执行 bear make -j 8 编译完成后，会在源码包的根目录下生成 compile_commands.json 文件。 4、通过 vscode 阅读内核源码，可自由跳转了","tags":[{"name":"vscode阅读Linux内核源码","slug":"vscode阅读Linux内核源码","permalink":"https://algorithmofdish.tech/tags/vscode%E9%98%85%E8%AF%BBLinux%E5%86%85%E6%A0%B8%E6%BA%90%E7%A0%81/"}]},{"title":"Go语言：select语句","date":"2022-01-16T10:12:24.000Z","path":"2022/01/16/go-yu-yan-select-yu-ju/","text":"[toc] Go语言：select语句语法功能：select 随机执行一个可运行的 case。如果没有 case 可运行，它将阻塞，直到有 case 可运行。 语法： select &#123; case clauseA: statementA case clauseB: statementB default: statementC &#125; 说明： case 中表达式必须是 Channel 收发操作。 无论哪一个表达式返回，都会立刻执行 case 中的代码。 当 select 中两个 case 同时被触发时，会随机执行其中一个，从而避免饥饿问题发生。 default 语句：提供非阻塞的收发的特性。若存在可收发的 Channel ，直接处理该 case 的语句；否则，执行 default 中的语句。 select 能够让 Goroutine 同时等待多个 Channel 可读或可写，在多个文件或者 Channel 状态改变之前，select 会一直阻塞当前线程或 Goroutine 。 select 的几种使用场景 阻塞操作 使用空的 select 语句，会直接阻塞当前 Goroutine，导致 Goroutine 进入无法被唤醒的永久休眠状态。 func example() &#123; select &#123;&#125; &#125; 单一管道 select 中只包含一个 case ，编译器会将 select 改写成 if 条件语句。若 case 中 Channel 是空指针时，会直接挂起当前 Goroutine 并陷入永久休眠。 func example() &#123; c := make(chan string) go func() &#123; time.Sleep(time.Second) c &lt;- \"one message\" &#125; select &#123; case msg := &lt;- c: fmt.Println(\"received\", msg) &#125; // 等价于 // if msg := &lt;- c &#123; // fmt.Println(\"received\", msg) // &#125; &#125; 非阻塞操作： select中包含多个case，且其中一个是 default 语句。若不存在可收发的 Channel ，直接执行 default 中的语句。 func example() &#123; c := make(chan string) select &#123; case msg := &lt;- c: fmt.Println(\"received\", msg) default: fmt.Println(\"no message received\") &#125; &#125; 编译器对 select 的处理编译器对 select 语句的一般处理流程： 将所有 case 转换成包含 Channel 以及类型等信息的 runtime.scase 结构体。 调用 runtime.selectgo 从多个就绪的 Channel 中选择一个可执行的 runtime.scase 结构体。 通过 for 循环生成一组 if 语句，在语句中判断自己是不是被选中的 case 。 随机执行的关键运行时函数：runtime.selectgo ，它的执行步骤为， 确定 case 的处理顺序 轮询顺序：通过 runtime.fastrandom 函数引入随机性。 加锁顺序：按照 Channel 的地址排序后确定加锁顺序。 根据轮询顺序遍历所有的 case ，查看是否有可立即处理的 Channel 。 如果存在，直接获取 case 对应的索引并返回 否则，创建 runtime.sudog 结构体，并将当前 Goroutine 加入到所有相关的 Channel 收发队列，并调用 runtime.gopark 挂起当前 Goroutine ，等待调度器的唤醒。 当调度器唤醒当前 Goroutine 时，会再次按照加锁顺序遍历所有的 case ，从中查找需要被处理的 runtime.sudog 对应的索引。 select 关键字是 Go 语言特有的控制结构，需要编译器和运行时函数共同实现。","tags":[{"name":"go","slug":"go","permalink":"https://algorithmofdish.tech/tags/go/"},{"name":"select","slug":"select","permalink":"https://algorithmofdish.tech/tags/select/"}]},{"title":"linked-list-cycle-ii","date":"2021-05-05T14:27:27.000Z","path":"2021/05/05/linked-list-cycle-ii/","text":"[toc] Leetcode链接：https://leetcode-cn.com/problems/linked-list-cycle-ii/ 题目描述给定一个链表，返回链表开始入环的第一个节点。 如果链表无环，则返回 null。 为了表示给定链表中的环，我们使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。 如果 pos 是 -1，则在该链表中没有环。注意，pos 仅仅是用于标识环的情况，并不会作为参数传递到函数中。 说明：不允许修改给定的链表。 解题思路分两个步骤， 首先通过快慢指针的方法判断链表是否有环； 接下来如果有环，则寻找入环的第一个节点。 判断链表是否有环很简单，如果快指针为 null 时，则链表无环；否则有环。 如果有环，则寻找入环的第一个节点，具体的方法为， 首先假定链表起点到入环的第一个节点A的长度为a【未知】，到快慢指针相遇的节点B的长度为（a + b）【这个长度是已知的】。 现在我们想知道a的值，注意到快指针 p_fast 始终是慢指针p走过长度的2倍，所以慢指针 p_slow 从B继续走（a + b）又能回到B点，如果只走a个长度就能回到节点A。 但是a的值是不知道的，解决思路是曲线救国，注意到起点到A的长度是a，那么可以用一个从起点开始的新慢指针 p_slow2 和从节点B开始的慢指针 p_slow 同步走，相遇的地方必然是入环的第一个节点A。 编码实现/** * Definition for singly-linked list. * class ListNode &#123; * int val; * ListNode next; * ListNode(int x) &#123; * val = x; * next = null; * &#125; * &#125; */ public class Solution &#123; public ListNode detectCycle(ListNode head) &#123; if (head == null) return null; // 步骤一：使用快慢指针判断链表是否有环 ListNode p = head, p2 = head; boolean hasCycle = false; while (p2.next != null &amp;&amp; p2.next.next != null) &#123; p = p.next; p2 = p2.next.next; if (p == p2) &#123; hasCycle = true; break; &#125; &#125; // 步骤二：若有环，找到入环开始的节点 if (hasCycle) &#123; ListNode q = head; while (p != q) &#123; p = p.next; q = q.next; &#125; return q; &#125; else return null; &#125; &#125;","tags":[{"name":"快慢指针","slug":"快慢指针","permalink":"https://algorithmofdish.tech/tags/%E5%BF%AB%E6%85%A2%E6%8C%87%E9%92%88/"},{"name":"链表","slug":"链表","permalink":"https://algorithmofdish.tech/tags/%E9%93%BE%E8%A1%A8/"}]},{"title":"Hexo上markdown图片路径与Typora保持一致","date":"2021-05-05T09:26:13.000Z","path":"2021/05/05/hexo-shang-markdown-tu-pian-lu-jing-yu-typora-bao-chi-yi-zhi/","text":"Typora是一款很好用的markdown语法编辑器，我希望使用Typora写好博客后，直接通过hexo部署到个人博客主页上面去。但有个问题是，如果markdown文件里面有图片路径时，在部署到hexo上时需要重新修改图片路径，否则会有问题。每次手动修改显然很麻烦，因此需要看看hexo是否有比较友好的支持。 Typora本地插入图片的路径有两种方式：一个是绝对路径，一个是相对路径（相对于当前文件所在的路径）。 Hexo通过hexo-renderer-marked插件实现了对markdown语法的支持，其中默认插入图片的方式为 ![](/images/image.jpg) ，它是一个相对路径（相对于Hexo工作目录下的 source 文件夹）的方式。 首先，如果Typora使用本地的绝对路径插入图片，那么在执行 hexo g 时需要将本地的绝对路径转换成对应的相对路径，这个目前暂未看到有相关的插件实现。 其次，如果Typora使用相对路径插入图片，问题在于Typora和Hexo所相对的路径是不一致的。对此，Hexo提供了一个更组织化的方式来管理资源，可以通过将 _config.yml 配置文件中的 post_asset_folder 选项设置为 true 来打开。 # _config.yml post_asset_folder: true 该功能打开后，Hexo将会在你每一次通过 hexo new [layout] &lt;title&gt; 命令创建新文章时自动创建一个文件夹。这个资源文件夹名与这个文章文件名相同。将所有与你的文章有关的资源（如图片）放在这个关联文件夹中之后，你可以通过相对路径来引用它们。如，我使用 hexo new mytitle 创建了一篇文章 mytitle.md ，会同时在该文章文件所在的路径上创建文件夹 mytitle/，我们在该文件夹里面添加图片 mytitle/my.png，这时我们在 mytitle.md 文件中插入该图片的方式为 ![](my.png) 就可以了。 跟Typora很接近了，但Typora需要的是 &#123;% asset_img my.png %&#125; （此处显示有个bug，Hexo自动将满足 mytitle/my.png 格式的图片路径转换成Hexo图片标签插件了，而实际上这里我用了反引号，按理说不应该转义的。。。），即 ![](mytitle&#x2F;my.png) 因此还需要一步转换：mytitle/my.png -&gt; my.png 。幸运的是，Hexo提供了一款插件 hexo-image-link 来实现这一步转换，在Hexo根目录下执行 npm install hexo-image-link --save 安装该插件即可，无需额外的配置。 至此，问题解决！总结下来操作上只需要做两个步骤即可： 安装插件 hexo-image-link npm install hexo-image-link --save 打开Hexo资源管理配置开关 # _config.yml post_asset_folder: true 最后，上一个例子，在本篇博客最后编辑一行， &#x2F;&#x2F; source&#x2F;_posts&#x2F;2021&#x2F;05&#x2F;05&#x2F;Hexo上markdown图片路径与Typora保持一致.md ![](Hexo上markdown图片路径与Typora保持一致&#x2F;古剑3.jpg) 接下来你可以看到本篇博客显示如下图片，","tags":[{"name":"博客","slug":"博客","permalink":"https://algorithmofdish.tech/tags/%E5%8D%9A%E5%AE%A2/"}]}]