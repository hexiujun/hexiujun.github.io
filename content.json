[{"title":"设计模式之装饰器模式","date":"2022-05-07T11:52:33.000Z","path":"2022/05/07/she-ji-mo-shi-zhi-zhuang-shi-qi-mo-shi/","text":"课程笔记：极客时间—设计模式之美 装饰器模式解决的问题：装饰器模式主要解决继承关系过于复杂的问题，通过组合来代替继承。 主要的作用：给原始类添加增强功能。 案例讲解：通过剖析 Java IO 类的设计思想来学习装饰器模式Java IO类库的部分继承关系： 字节流 InputStream（抽象类） PipedInputStream FileInputStream FilterInputStream BufferedInputStream DataInputStream OutputStream（抽象类） 字符流 其中，FileInputStream 是专门用来读取文件流的子类。BufferedInputStream是一个支持带缓存功能的数据读取类，可以提高数据读取的效率。 考虑给 FileInputStream 扩展一个支持带缓存读取的功能，有两种设计方案： 基于继承的设计方案 添加一个继承 FileInputStream 的子类 BufferedFileInputStream 来实现该功能。 该方案的问题：假如我需要再给 PipedInputStream 添加缓存功能，则需要再添加一个继承自 PipedInputStream 的子类 BufferedPipedInputStream ；另外，除了支持缓存读取之外，如果我们还需要对功能进行其他方面的增强，比如 DataInputStream 类（支持按照基本数据类型来读取数据），就需要再继续派生出 DataFileInputStream 、 DataPipedInputStream 等 n 多个子类。依此类推，如果需要附加更多的增强功能（假设有 m 个），那么就会导致组合爆炸（新增 m x n 个子类），类继承结构变得无比复杂，代码既不好扩展，也不好维护。 基于装饰器模式的设计方案 简而言之，就是“使用组合来替代继承”。 这里给出了部分的代码实现结构： public abstract class InputStream &#123; public int read(byte b[]) throws IOException &#123; return read(b, 0, b.length); &#125; public long skip(long n) throws IOException &#123; //... &#125; &#125; public class BufferedInputStream extends InputStream &#123; protected volatile InputStream in; protected BufferedInputStream(InputStream in) &#123; this.in = in; &#125; // 实现基于缓存的读数据接口 &#125; public class DataInputStream extends InputStream &#123; protected volatile InputStream in; protected DataInputStream(InputStream in) &#123; this.in = in; &#125; // 实现基于读取基本类型数据的接口 &#125; 使用下面的代码，我们就可以分别创建一个支持缓存功能、和支持读取基本数据类型的读取文件流。 InputStream bin = new BufferedInputStream(new FileInputStream(\"/path/to/test.txt\")); InputStream din = new DataInputStream(new FileInputStream(\"/path/to/test.txt\")); 如果总共需要添加 m 个附加功能，那我们只需要创建 m 个继承自 InputStream 的子类即可。 装饰器模式相对于简单的组合关系，还有两个比较特殊的地方。 第一个特殊的地方：装饰器类和原始类继承同样的父类，这样我们可以对原始类“嵌套”多个装饰器类。 比如，下面一段代码，通过对 FileInputStream 嵌套了两个装饰器类，让它既支持缓存读取，又支持按照基本数据类型来读取数据。 InputStream in = new FileInputStream(\"/path/to/test.txt\"); InputStream bin = new BufferedInputStream(in); InputStream din = new DataInputStream(bin); 不得不感叹这样的设计是真的优雅。 第二个特殊的地方：装饰器类是对功能的增强，这也是装饰器模式应用场景的一个重要特点。 这里我们通过对比装饰器模式和代理模式的设计差异来加深认识。 代理模式跟装饰器模式的代码结构很像，它们都是符合“组合关系”的设计。但是，它们的设计意图是不同的。 代理模式中，代理类附加的是跟原始类无关的功能； 装饰器模式中，装饰器类附加的是跟原始类相关的增强功能。 // 代理模式的代码结构（下面的接口可替换成抽象类） public interface IA &#123; void f(); &#125; public class A implements IA &#123; public void f() &#123;&#125; &#125; public class AProxy implements IA &#123; private IA a; public AProxy(IA a) &#123; this.a = a; &#125; public void f() &#123; // 新添加的代理逻辑 a.f(); // 新添加的代理逻辑 &#125; &#125; // 装饰器模式的代码结构（下面的接口可替换成抽象类） public interface IA &#123; void f(); void f2(); &#125; public class A implements IA &#123; public void f() &#123;&#125; public void f2() &#123;&#125; &#125; public class ADecorator implements IA &#123; private IA a; public ADecorator(IA a) &#123; this.a = a; &#125; public void f() &#123; // 功能增强代码 a.f(); // 功能增强代码 &#125; public void f2() &#123; a.f2(); &#125; &#125; 在装饰器模式中，即使对于不需要增强的函数来说，装饰器类还是必须把它重新实现一遍，简单包裹对被装饰类的函数调用。原因也很容易理解，装饰器类既然是对原始类功能的增强，那么原始类已有的功能就必须被继承下来。而这带来了一个问题，增加了重复代码。 聪明的你可能已经想到了解决方案：使用继承。这也是 Java IO 类的设计中，BufferedInputStream 并没有直接继承自 InputStream，而是抽象出了一个装饰器父类 FilterInputStream 的原因所在。这样，装饰器类只需要实现它需要增强的方法就可以了，其他方法继承装饰器父类的默认实现。 public class FilterInputStream extends InputStream &#123; protected volatile InputStream in; protected FilterInputStream(InputStream in) &#123; this.in = in; &#125; public int read(byte b[]) throws IOException &#123; return in.read(b); &#125; public long skip(long n) throws IOException &#123; return in.skip(n); &#125; &#125; 装饰器模式类图","tags":[{"name":"设计模式","slug":"设计模式","permalink":"https://algorithmofdish.tech/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"name":"装饰器模式","slug":"装饰器模式","permalink":"https://algorithmofdish.tech/tags/%E8%A3%85%E9%A5%B0%E5%99%A8%E6%A8%A1%E5%BC%8F/"}]},{"title":"vscode + Remote SSH + clangd Linux内核源码阅读环境搭建","date":"2022-04-04T05:19:04.000Z","path":"2022/04/04/vscode-remote-ssh-clangd-linux-nei-he-yuan-ma-yue-du-huan-jing-da-jian/","text":"1、vscode + Remote SSH 远程连接Linux虚拟机环境说明 vscode运行在Windows环境 Linux虚拟机是在Windows环境下通过VMWare安装 Linux版本：openEuler 22.03 涉及到的软件包安装基本上都是基于 rpm 包安装的 连接配置过程 安装 Remote - SSH 插件 添加远程主机 首先，打开 vscode 命令输入栏（快捷键 F1 或 Ctrl + Shift + P），搜索 Remote-SSH: Connect to Host... ，回车。 在连接窗口中，输入你要远程连接的远程主机（这里是我的Linux虚拟机），输入格式为：user@host，如 root@192.168.0.111 ，回车。 此时会弹出一个新的 vscode 窗口，依此选择远程主机的系统类型（我的是 Linux），输入远程主机的密码，回车。 如果一切正常的话，你将成功连上你的远程主机，此时 vscode 窗口左下角会出现 SSH: 192.168.x.x 表示你连上的远程主机IP。另外，你可以在 explorer 侧边栏点击 OpenFolder ，此时会弹出远程主机的文件目录结构，选择一个文件夹作为你的工作目录即可。 至此，你就可以直接在Windows环境下通过 vscode 操作远程主机上的代码了。 遇到的问题 远程主机一直连不上，打开 vscode 的输出控制台，打印 open failed: administratively prohibited: open failed 字样的错误。 去 vscode 官网，查看 Remote-SSH 插件的问题处理文档：https://code.visualstudio.com/docs/remote/troubleshooting#_troubleshooting-hanging-or-failing-connections ，搜索关键字，找到相应的解决办法。 2、安装 clangd 插件安装 clangd 插件，安装好后在 settings.json 中添加如下 clangd 的配置（可按需扩展）， \"clangd.arguments\": [ \"--compile-commands-dir=$&#123;workspaceFolder&#125;\", \"--background-index\", \"--completion-style=detailed\", \"-log=info\" ], 注意，clangd 插件跟 C/C++ 插件是冲突的，如果使用 clangd 的功能，需要禁用 C/C++ 插件。 \"C_Cpp.intelliSenseEngine\": \"Disabled\" 另外，在使用 Remote - SSH 连接上远程 Linux 虚拟机后，需要同时在远程 Linux 虚拟机上安装 clangd 插件，根据 Extensions 侧边栏 clangd 插件的提示按钮 Install in SSH: 192.168.x.x 点击安装即可（可能安装不成功，看后面手动安装步骤）。安装好后，拷贝 clangd 插件的配置到远程 Linux 虚拟机上的 clangd 上，同时配置远程 Linux 虚拟机上安装的 clangd 的可执行文件路径。 手动在远程 Linux 虚拟机上安装 clangd 直接在 github 发布页面上下载 clangd 的二进制包，我下载的是 13.0.0 版本的 clangd ： https://github.com/clangd/clangd/releases/tag/13.0.0 拷贝二进制包到 Linux 安装目录，解压即可。 unzip clangd-linux-13.0.0.zip 在解压后的文件夹中找到二进制文件 clangd 的文件路径，并在 vscode 中配置远程 Linux 虚拟机上安装的 clangd 的可执行文件路径。（如上所述） 3、生成 clangd 需要的配置文件 compile_commands.json安装 bear 直接在 https://koji.fedoraproject.org/koji/ 下载合适的 bear 版本的 rpm 包，我下载的版本 bear-2.4.4-1.fc31 。 将 rpm 包拷到 Linux 虚拟机上，通过 yum install bear-2.4.4-1.fc31.x86_64.rpm 安装即可。 编译内核代码生成compile_commands.json参考文档：https://www.cyberciti.biz/tips/compiling-linux-kernel-26.html 下载指定的内核版本的源码包，可以直接去官网下载：https://www.kernel.org/ 解压源码包 tar -zxvf kernel.tar.gz ，并进入源码包的根目录。 可以直接拷贝当前Linux虚拟机的内核配置文件（cp -v /boot/config-$(uname -r) .config），或直接使用 make menuconfig 来配置内核支持的特性和模块配置。 安装编译依赖的工具包 yum group install &quot;Development Tools&quot; yum install ncurses-devel bison flex elfutils-libelf-devel openssl-devel 使用 bear 编译内核，执行 bear make -j 8 编译完成后，会在源码包的根目录下生成 compile_commands.json 文件。 4、通过 vscode 阅读内核源码，可自由跳转了","tags":[{"name":"vscode阅读Linux内核源码","slug":"vscode阅读Linux内核源码","permalink":"https://algorithmofdish.tech/tags/vscode%E9%98%85%E8%AF%BBLinux%E5%86%85%E6%A0%B8%E6%BA%90%E7%A0%81/"}]},{"title":"Go语言：select语句","date":"2022-01-16T10:12:24.000Z","path":"2022/01/16/go-yu-yan-select-yu-ju/","text":"[toc] Go语言：select语句语法功能：select 随机执行一个可运行的 case。如果没有 case 可运行，它将阻塞，直到有 case 可运行。 语法： select &#123; case clauseA: statementA case clauseB: statementB default: statementC &#125; 说明： case 中表达式必须是 Channel 收发操作。 无论哪一个表达式返回，都会立刻执行 case 中的代码。 当 select 中两个 case 同时被触发时，会随机执行其中一个，从而避免饥饿问题发生。 default 语句：提供非阻塞的收发的特性。若存在可收发的 Channel ，直接处理该 case 的语句；否则，执行 default 中的语句。 select 能够让 Goroutine 同时等待多个 Channel 可读或可写，在多个文件或者 Channel 状态改变之前，select 会一直阻塞当前线程或 Goroutine 。 select 的几种使用场景 阻塞操作 使用空的 select 语句，会直接阻塞当前 Goroutine，导致 Goroutine 进入无法被唤醒的永久休眠状态。 func example() &#123; select &#123;&#125; &#125; 单一管道 select 中只包含一个 case ，编译器会将 select 改写成 if 条件语句。若 case 中 Channel 是空指针时，会直接挂起当前 Goroutine 并陷入永久休眠。 func example() &#123; c := make(chan string) go func() &#123; time.Sleep(time.Second) c &lt;- \"one message\" &#125; select &#123; case msg := &lt;- c: fmt.Println(\"received\", msg) &#125; // 等价于 // if msg := &lt;- c &#123; // fmt.Println(\"received\", msg) // &#125; &#125; 非阻塞操作： select中包含多个case，且其中一个是 default 语句。若不存在可收发的 Channel ，直接执行 default 中的语句。 func example() &#123; c := make(chan string) select &#123; case msg := &lt;- c: fmt.Println(\"received\", msg) default: fmt.Println(\"no message received\") &#125; &#125; 编译器对 select 的处理编译器对 select 语句的一般处理流程： 将所有 case 转换成包含 Channel 以及类型等信息的 runtime.scase 结构体。 调用 runtime.selectgo 从多个就绪的 Channel 中选择一个可执行的 runtime.scase 结构体。 通过 for 循环生成一组 if 语句，在语句中判断自己是不是被选中的 case 。 随机执行的关键运行时函数：runtime.selectgo ，它的执行步骤为， 确定 case 的处理顺序 轮询顺序：通过 runtime.fastrandom 函数引入随机性。 加锁顺序：按照 Channel 的地址排序后确定加锁顺序。 根据轮询顺序遍历所有的 case ，查看是否有可立即处理的 Channel 。 如果存在，直接获取 case 对应的索引并返回 否则，创建 runtime.sudog 结构体，并将当前 Goroutine 加入到所有相关的 Channel 收发队列，并调用 runtime.gopark 挂起当前 Goroutine ，等待调度器的唤醒。 当调度器唤醒当前 Goroutine 时，会再次按照加锁顺序遍历所有的 case ，从中查找需要被处理的 runtime.sudog 对应的索引。 select 关键字是 Go 语言特有的控制结构，需要编译器和运行时函数共同实现。","tags":[{"name":"go","slug":"go","permalink":"https://algorithmofdish.tech/tags/go/"},{"name":"select","slug":"select","permalink":"https://algorithmofdish.tech/tags/select/"}]},{"title":"linked-list-cycle-ii","date":"2021-05-05T14:27:27.000Z","path":"2021/05/05/linked-list-cycle-ii/","text":"[toc] Leetcode链接：https://leetcode-cn.com/problems/linked-list-cycle-ii/ 题目描述给定一个链表，返回链表开始入环的第一个节点。 如果链表无环，则返回 null。 为了表示给定链表中的环，我们使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。 如果 pos 是 -1，则在该链表中没有环。注意，pos 仅仅是用于标识环的情况，并不会作为参数传递到函数中。 说明：不允许修改给定的链表。 解题思路分两个步骤， 首先通过快慢指针的方法判断链表是否有环； 接下来如果有环，则寻找入环的第一个节点。 判断链表是否有环很简单，如果快指针为 null 时，则链表无环；否则有环。 如果有环，则寻找入环的第一个节点，具体的方法为， 首先假定链表起点到入环的第一个节点A的长度为a【未知】，到快慢指针相遇的节点B的长度为（a + b）【这个长度是已知的】。 现在我们想知道a的值，注意到快指针 p_fast 始终是慢指针p走过长度的2倍，所以慢指针 p_slow 从B继续走（a + b）又能回到B点，如果只走a个长度就能回到节点A。 但是a的值是不知道的，解决思路是曲线救国，注意到起点到A的长度是a，那么可以用一个从起点开始的新慢指针 p_slow2 和从节点B开始的慢指针 p_slow 同步走，相遇的地方必然是入环的第一个节点A。 编码实现/** * Definition for singly-linked list. * class ListNode &#123; * int val; * ListNode next; * ListNode(int x) &#123; * val = x; * next = null; * &#125; * &#125; */ public class Solution &#123; public ListNode detectCycle(ListNode head) &#123; if (head == null) return null; // 步骤一：使用快慢指针判断链表是否有环 ListNode p = head, p2 = head; boolean hasCycle = false; while (p2.next != null &amp;&amp; p2.next.next != null) &#123; p = p.next; p2 = p2.next.next; if (p == p2) &#123; hasCycle = true; break; &#125; &#125; // 步骤二：若有环，找到入环开始的节点 if (hasCycle) &#123; ListNode q = head; while (p != q) &#123; p = p.next; q = q.next; &#125; return q; &#125; else return null; &#125; &#125;","tags":[{"name":"快慢指针","slug":"快慢指针","permalink":"https://algorithmofdish.tech/tags/%E5%BF%AB%E6%85%A2%E6%8C%87%E9%92%88/"},{"name":"链表","slug":"链表","permalink":"https://algorithmofdish.tech/tags/%E9%93%BE%E8%A1%A8/"}]},{"title":"Hexo上markdown图片路径与Typora保持一致","date":"2021-05-05T09:26:13.000Z","path":"2021/05/05/hexo-shang-markdown-tu-pian-lu-jing-yu-typora-bao-chi-yi-zhi/","text":"Typora是一款很好用的markdown语法编辑器，我希望使用Typora写好博客后，直接通过hexo部署到个人博客主页上面去。但有个问题是，如果markdown文件里面有图片路径时，在部署到hexo上时需要重新修改图片路径，否则会有问题。每次手动修改显然很麻烦，因此需要看看hexo是否有比较友好的支持。 Typora本地插入图片的路径有两种方式：一个是绝对路径，一个是相对路径（相对于当前文件所在的路径）。 Hexo通过hexo-renderer-marked插件实现了对markdown语法的支持，其中默认插入图片的方式为 ![](/images/image.jpg) ，它是一个相对路径（相对于Hexo工作目录下的 source 文件夹）的方式。 首先，如果Typora使用本地的绝对路径插入图片，那么在执行 hexo g 时需要将本地的绝对路径转换成对应的相对路径，这个目前暂未看到有相关的插件实现。 其次，如果Typora使用相对路径插入图片，问题在于Typora和Hexo所相对的路径是不一致的。对此，Hexo提供了一个更组织化的方式来管理资源，可以通过将 _config.yml 配置文件中的 post_asset_folder 选项设置为 true 来打开。 # _config.yml post_asset_folder: true 该功能打开后，Hexo将会在你每一次通过 hexo new [layout] &lt;title&gt; 命令创建新文章时自动创建一个文件夹。这个资源文件夹名与这个文章文件名相同。将所有与你的文章有关的资源（如图片）放在这个关联文件夹中之后，你可以通过相对路径来引用它们。如，我使用 hexo new mytitle 创建了一篇文章 mytitle.md ，会同时在该文章文件所在的路径上创建文件夹 mytitle/，我们在该文件夹里面添加图片 mytitle/my.png，这时我们在 mytitle.md 文件中插入该图片的方式为 ![](my.png) 就可以了。 跟Typora很接近了，但Typora需要的是 &#123;% asset_img my.png %&#125; （此处显示有个bug，Hexo自动将满足 mytitle/my.png 格式的图片路径转换成Hexo图片标签插件了，而实际上这里我用了反引号，按理说不应该转义的。。。），即 ![](mytitle&#x2F;my.png) 因此还需要一步转换：mytitle/my.png -&gt; my.png 。幸运的是，Hexo提供了一款插件 hexo-image-link 来实现这一步转换，在Hexo根目录下执行 npm install hexo-image-link --save 安装该插件即可，无需额外的配置。 至此，问题解决！总结下来操作上只需要做两个步骤即可： 安装插件 hexo-image-link npm install hexo-image-link --save 打开Hexo资源管理配置开关 # _config.yml post_asset_folder: true 最后，上一个例子，在本篇博客最后编辑一行， &#x2F;&#x2F; source&#x2F;_posts&#x2F;2021&#x2F;05&#x2F;05&#x2F;Hexo上markdown图片路径与Typora保持一致.md ![](Hexo上markdown图片路径与Typora保持一致&#x2F;古剑3.jpg) 接下来你可以看到本篇博客显示如下图片，","tags":[{"name":"博客","slug":"博客","permalink":"https://algorithmofdish.tech/tags/%E5%8D%9A%E5%AE%A2/"}]}]