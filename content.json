[{"title":"Go语言：select语句","date":"2022-01-16T10:12:24.000Z","path":"2022/01/16/go-yu-yan-select-yu-ju/","text":"[toc] Go语言：select语句语法功能：select 随机执行一个可运行的 case。如果没有 case 可运行，它将阻塞，直到有 case 可运行。 语法： select &#123; case clauseA: statementA case clauseB: statementB default: statementC &#125; 说明： case 中表达式必须是 Channel 收发操作。 无论哪一个表达式返回，都会立刻执行 case 中的代码。 当 select 中两个 case 同时被触发时，会随机执行其中一个，从而避免饥饿问题发生。 default 语句：提供非阻塞的收发的特性。若存在可收发的 Channel ，直接处理该 case 的语句；否则，执行 default 中的语句。 select 能够让 Goroutine 同时等待多个 Channel 可读或可写，在多个文件或者 Channel 状态改变之前，select 会一直阻塞当前线程或 Goroutine 。 select 的几种使用场景 阻塞操作 使用空的 select 语句，会直接阻塞当前 Goroutine，导致 Goroutine 进入无法被唤醒的永久休眠状态。 func example() &#123; select &#123;&#125; &#125; 单一管道 select 中只包含一个 case ，编译器会将 select 改写成 if 条件语句。若 case 中 Channel 是空指针时，会直接挂起当前 Goroutine 并陷入永久休眠。 func example() &#123; c := make(chan string) go func() &#123; time.Sleep(time.Second) c &lt;- \"one message\" &#125; select &#123; case msg := &lt;- c: fmt.Println(\"received\", msg) &#125; // 等价于 // if msg := &lt;- c &#123; // fmt.Println(\"received\", msg) // &#125; &#125; 非阻塞操作： select中包含多个case，且其中一个是 default 语句。若不存在可收发的 Channel ，直接执行 default 中的语句。 func example() &#123; c := make(chan string) select &#123; case msg := &lt;- c: fmt.Println(\"received\", msg) default: fmt.Println(\"no message received\") &#125; &#125; 编译器对 select 的处理编译器对 select 语句的一般处理流程： 将所有 case 转换成包含 Channel 以及类型等信息的 runtime.scase 结构体。 调用 runtime.selectgo 从多个就绪的 Channel 中选择一个可执行的 runtime.scase 结构体。 通过 for 循环生成一组 if 语句，在语句中判断自己是不是被选中的 case 。 随机执行的关键运行时函数：runtime.selectgo ，它的执行步骤为， 确定 case 的处理顺序 轮询顺序：通过 runtime.fastrandom 函数引入随机性。 加锁顺序：按照 Channel 的地址排序后确定加锁顺序。 根据轮询顺序遍历所有的 case ，查看是否有可立即处理的 Channel 。 如果存在，直接获取 case 对应的索引并返回 否则，创建 runtime.sudog 结构体，并将当前 Goroutine 加入到所有相关的 Channel 收发队列，并调用 runtime.gopark 挂起当前 Goroutine ，等待调度器的唤醒。 当调度器唤醒当前 Goroutine 时，会再次按照加锁顺序遍历所有的 case ，从中查找需要被处理的 runtime.sudog 对应的索引。 select 关键字是 Go 语言特有的控制结构，需要编译器和运行时函数共同实现。","tags":[{"name":"go","slug":"go","permalink":"https://algorithmofdish.tech/tags/go/"},{"name":"select","slug":"select","permalink":"https://algorithmofdish.tech/tags/select/"}]},{"title":"linked-list-cycle-ii","date":"2021-05-05T14:27:27.000Z","path":"2021/05/05/linked-list-cycle-ii/","text":"[toc] Leetcode链接：https://leetcode-cn.com/problems/linked-list-cycle-ii/ 题目描述给定一个链表，返回链表开始入环的第一个节点。 如果链表无环，则返回 null。 为了表示给定链表中的环，我们使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。 如果 pos 是 -1，则在该链表中没有环。注意，pos 仅仅是用于标识环的情况，并不会作为参数传递到函数中。 说明：不允许修改给定的链表。 解题思路分两个步骤， 首先通过快慢指针的方法判断链表是否有环； 接下来如果有环，则寻找入环的第一个节点。 判断链表是否有环很简单，如果快指针为 null 时，则链表无环；否则有环。 如果有环，则寻找入环的第一个节点，具体的方法为， 首先假定链表起点到入环的第一个节点A的长度为a【未知】，到快慢指针相遇的节点B的长度为（a + b）【这个长度是已知的】。 现在我们想知道a的值，注意到快指针 p_fast 始终是慢指针p走过长度的2倍，所以慢指针 p_slow 从B继续走（a + b）又能回到B点，如果只走a个长度就能回到节点A。 但是a的值是不知道的，解决思路是曲线救国，注意到起点到A的长度是a，那么可以用一个从起点开始的新慢指针 p_slow2 和从节点B开始的慢指针 p_slow 同步走，相遇的地方必然是入环的第一个节点A。 编码实现/** * Definition for singly-linked list. * class ListNode &#123; * int val; * ListNode next; * ListNode(int x) &#123; * val = x; * next = null; * &#125; * &#125; */ public class Solution &#123; public ListNode detectCycle(ListNode head) &#123; if (head == null) return null; // 步骤一：使用快慢指针判断链表是否有环 ListNode p = head, p2 = head; boolean hasCycle = false; while (p2.next != null &amp;&amp; p2.next.next != null) &#123; p = p.next; p2 = p2.next.next; if (p == p2) &#123; hasCycle = true; break; &#125; &#125; // 步骤二：若有环，找到入环开始的节点 if (hasCycle) &#123; ListNode q = head; while (p != q) &#123; p = p.next; q = q.next; &#125; return q; &#125; else return null; &#125; &#125;","tags":[{"name":"快慢指针","slug":"快慢指针","permalink":"https://algorithmofdish.tech/tags/%E5%BF%AB%E6%85%A2%E6%8C%87%E9%92%88/"},{"name":"链表","slug":"链表","permalink":"https://algorithmofdish.tech/tags/%E9%93%BE%E8%A1%A8/"}]},{"title":"Hexo上markdown图片路径与Typora保持一致","date":"2021-05-05T09:26:13.000Z","path":"2021/05/05/hexo-shang-markdown-tu-pian-lu-jing-yu-typora-bao-chi-yi-zhi/","text":"Typora是一款很好用的markdown语法编辑器，我希望使用Typora写好博客后，直接通过hexo部署到个人博客主页上面去。但有个问题是，如果markdown文件里面有图片路径时，在部署到hexo上时需要重新修改图片路径，否则会有问题。每次手动修改显然很麻烦，因此需要看看hexo是否有比较友好的支持。 Typora本地插入图片的路径有两种方式：一个是绝对路径，一个是相对路径（相对于当前文件所在的路径）。 Hexo通过hexo-renderer-marked插件实现了对markdown语法的支持，其中默认插入图片的方式为 ![](/images/image.jpg) ，它是一个相对路径（相对于Hexo工作目录下的 source 文件夹）的方式。 首先，如果Typora使用本地的绝对路径插入图片，那么在执行 hexo g 时需要将本地的绝对路径转换成对应的相对路径，这个目前暂未看到有相关的插件实现。 其次，如果Typora使用相对路径插入图片，问题在于Typora和Hexo所相对的路径是不一致的。对此，Hexo提供了一个更组织化的方式来管理资源，可以通过将 _config.yml 配置文件中的 post_asset_folder 选项设置为 true 来打开。 # _config.yml post_asset_folder: true 该功能打开后，Hexo将会在你每一次通过 hexo new [layout] &lt;title&gt; 命令创建新文章时自动创建一个文件夹。这个资源文件夹名与这个文章文件名相同。将所有与你的文章有关的资源（如图片）放在这个关联文件夹中之后，你可以通过相对路径来引用它们。如，我使用 hexo new mytitle 创建了一篇文章 mytitle.md ，会同时在该文章文件所在的路径上创建文件夹 mytitle/，我们在该文件夹里面添加图片 mytitle/my.png，这时我们在 mytitle.md 文件中插入该图片的方式为 ![](my.png) 就可以了。 跟Typora很接近了，但Typora需要的是 &#123;% asset_img my.png %&#125; （此处显示有个bug，Hexo自动将满足 mytitle/my.png 格式的图片路径转换成Hexo图片标签插件了，而实际上这里我用了反引号，按理说不应该转义的。。。），即 ![](mytitle&#x2F;my.png) 因此还需要一步转换：mytitle/my.png -&gt; my.png 。幸运的是，Hexo提供了一款插件 hexo-image-link 来实现这一步转换，在Hexo根目录下执行 npm install hexo-image-link --save 安装该插件即可，无需额外的配置。 至此，问题解决！总结下来操作上只需要做两个步骤即可： 安装插件 hexo-image-link npm install hexo-image-link --save 打开Hexo资源管理配置开关 # _config.yml post_asset_folder: true 最后，上一个例子，在本篇博客最后编辑一行， &#x2F;&#x2F; source&#x2F;_posts&#x2F;2021&#x2F;05&#x2F;05&#x2F;Hexo上markdown图片路径与Typora保持一致.md ![](Hexo上markdown图片路径与Typora保持一致&#x2F;古剑3.jpg) 接下来你可以看到本篇博客显示如下图片，","tags":[{"name":"博客","slug":"博客","permalink":"https://algorithmofdish.tech/tags/%E5%8D%9A%E5%AE%A2/"}]}]